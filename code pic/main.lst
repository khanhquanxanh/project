CCS PCH C Compiler, Version 5.015, 5967               24-Dec-18 00:54

               Filename:   E:\php\CODE (1)\CODE\New folder\main.lst

               ROM used:   9978 bytes (30%)
                           Largest free fragment is 22786
               RAM used:   754 (37%) at main() level
                           792 (39%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   2334
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.0
004A:  GOTO   0054
004E:  BTFSC  F9E.0
0050:  GOTO   00A2
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0112
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
.................... #include <main.h> 
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
*
0142:  DATA 53,65
0144:  DATA 74,75
0146:  DATA 70,20
0148:  DATA 53,75
014A:  DATA 63,63
014C:  DATA 65,73
014E:  DATA 73,66
0150:  DATA 75,6C
0152:  DATA 0A,00
0154:  DATA 54,45
0156:  DATA 4D,50
0158:  DATA 3A,20
015A:  DATA 25,32
015C:  DATA 2E,32
015E:  DATA 66,0D
0160:  DATA 0A,00
0162:  DATA 44,4F
0164:  DATA 3A,20
0166:  DATA 25,32
0168:  DATA 2E,31
016A:  DATA 66,0D
016C:  DATA 0A,00
016E:  DATA 70,48
0170:  DATA 3A,20
0172:  DATA 25,32
0174:  DATA 2E,31
0176:  DATA 66,0D
0178:  DATA 0A,00
017A:  DATA 54,55
017C:  DATA 52,42
017E:  DATA 20,28
0180:  DATA 70,65
0182:  DATA 72,63
0184:  DATA 65,6E
0186:  DATA 74,29
0188:  DATA 3A,20
018A:  DATA 25,66
018C:  DATA 0D,0A
018E:  DATA 00,00
0190:  DATA 54,44
0192:  DATA 53,3A
0194:  DATA 20,25
0196:  DATA 33,2E
0198:  DATA 32,66
019A:  DATA 0D,0A
019C:  DATA 00,00
019E:  DATA 42,61
01A0:  DATA 74,20
01A2:  DATA 4D,4F
01A4:  DATA 44,55
01A6:  DATA 4C,45
01A8:  DATA 20,53
01AA:  DATA 49,4D
01AC:  DATA 3A,0A
01AE:  DATA 00,00
01B0:  DATA 54,61
01B2:  DATA 74,20
01B4:  DATA 70,68
01B6:  DATA 61,6E
01B8:  DATA 20,68
01BA:  DATA 6F,69
01BC:  DATA 20,73
01BE:  DATA 69,6D
01C0:  DATA 3A,20
01C2:  DATA 0A,00
01C4:  DATA 41,54
01C6:  DATA 45,30
01C8:  DATA 00,00
01CA:  DATA 4B,69
01CC:  DATA 65,6D
01CE:  DATA 20,54
01D0:  DATA 72,61
01D2:  DATA 20,4D
01D4:  DATA 6F,64
01D6:  DATA 75,6C
01D8:  DATA 65,20
01DA:  DATA 53,69
01DC:  DATA 6D,3A
01DE:  DATA 0A,00
01E0:  DATA 43,61
01E2:  DATA 75,20
01E4:  DATA 68,69
01E6:  DATA 6E,68
01E8:  DATA 20,53
01EA:  DATA 4D,53
01EC:  DATA 3A,00
01EE:  DATA 41,54
01F0:  DATA 2B,43
01F2:  DATA 4D,47
01F4:  DATA 46,3D
01F6:  DATA 31,00
01F8:  DATA 43,41
01FA:  DATA 55,20
01FC:  DATA 48,49
01FE:  DATA 4E,48
0200:  DATA 20,47
0202:  DATA 50,52
0204:  DATA 53,0A
0206:  DATA 00,00
0208:  DATA 41,54
020A:  DATA 2B,53
020C:  DATA 41,50
020E:  DATA 42,52
0210:  DATA 3D,33
0212:  DATA 2C,31
0214:  DATA 2C,22
0216:  DATA 43,6F
0218:  DATA 6E,74
021A:  DATA 79,70
021C:  DATA 65,22
021E:  DATA 2C,22
0220:  DATA 47,50
0222:  DATA 52,53
0224:  DATA 22,00
0226:  DATA 43,41
0228:  DATA 55,20
022A:  DATA 48,49
022C:  DATA 4E,48
022E:  DATA 20,41
0230:  DATA 50,4E
0232:  DATA 0A,00
0234:  DATA 41,54
0236:  DATA 2B,53
0238:  DATA 41,50
023A:  DATA 42,52
023C:  DATA 3D,33
023E:  DATA 2C,31
0240:  DATA 2C,22
0242:  DATA 41,50
0244:  DATA 4E,22
0246:  DATA 2C,22
0248:  DATA 77,61
024A:  DATA 70,22
024C:  DATA 00,00
024E:  DATA 0D,0A
0250:  DATA 53,45
0252:  DATA 4E,44
0254:  DATA 20,44
0256:  DATA 41,54
0258:  DATA 41,0D
025A:  DATA 0A,00
025C:  DATA 42,41
025E:  DATA 54,20
0260:  DATA 47,50
0262:  DATA 52,53
0264:  DATA 0A,00
0266:  DATA 41,54
0268:  DATA 2B,53
026A:  DATA 41,50
026C:  DATA 42,52
026E:  DATA 3D,31
0270:  DATA 2C,31
0272:  DATA 00,00
0274:  DATA 4B,48
0276:  DATA 4F,49
0278:  DATA 20,54
027A:  DATA 41,4F
027C:  DATA 20,48
027E:  DATA 54,4D
0280:  DATA 4C,0A
0282:  DATA 00,00
0284:  DATA 41,54
0286:  DATA 2B,48
0288:  DATA 54,54
028A:  DATA 50,49
028C:  DATA 4E,49
028E:  DATA 54,00
0290:  DATA 53,45
0292:  DATA 4E,44
0294:  DATA 20,55
0296:  DATA 52,4C
0298:  DATA 3A,20
029A:  DATA 00,00
029C:  DATA 41,54
029E:  DATA 2B,48
02A0:  DATA 54,54
02A2:  DATA 50,50
02A4:  DATA 41,52
02A6:  DATA 41,3D
02A8:  DATA 22,55
02AA:  DATA 52,4C
02AC:  DATA 22,2C
02AE:  DATA 22,77
02B0:  DATA 61,74
02B2:  DATA 65,72
02B4:  DATA 76,76
02B6:  DATA 76,2E
02B8:  DATA 30,30
02BA:  DATA 30,77
02BC:  DATA 65,62
02BE:  DATA 68,6F
02C0:  DATA 73,74
02C2:  DATA 61,70
02C4:  DATA 70,2E
02C6:  DATA 63,6F
02C8:  DATA 6D,2F
02CA:  DATA 75,70
02CC:  DATA 64,61
02CE:  DATA 74,65
02D0:  DATA 5F,64
02D2:  DATA 61,74
02D4:  DATA 61,2E
02D6:  DATA 70,68
02D8:  DATA 70,3F
02DA:  DATA 74,3D
02DC:  DATA 25,32
02DE:  DATA 2E,31
02E0:  DATA 66,26
02E2:  DATA 74,64
02E4:  DATA 73,3D
02E6:  DATA 25,32
02E8:  DATA 2E,31
02EA:  DATA 66,26
02EC:  DATA 64,6F
02EE:  DATA 3D,25
02F0:  DATA 32,2E
02F2:  DATA 31,66
02F4:  DATA 26,70
02F6:  DATA 68,3D
02F8:  DATA 25,32
02FA:  DATA 2E,31
02FC:  DATA 66,26
02FE:  DATA 74,75
0300:  DATA 72,62
0302:  DATA 3D,25
0304:  DATA 32,2E
0306:  DATA 31,66
0308:  DATA 22,00
030A:  DATA 4B,48
030C:  DATA 4F,49
030E:  DATA 20,54
0310:  DATA 41,4F
0312:  DATA 20,43
0314:  DATA 49,44
0316:  DATA 20,0A
0318:  DATA 00,00
031A:  DATA 41,54
031C:  DATA 2B,48
031E:  DATA 54,54
0320:  DATA 50,50
0322:  DATA 41,52
0324:  DATA 41,3D
0326:  DATA 22,43
0328:  DATA 49,44
032A:  DATA 22,2C
032C:  DATA 31,00
032E:  DATA 42,41
0330:  DATA 54,20
0332:  DATA 44,41
0334:  DATA 55,20
0336:  DATA 54,48
0338:  DATA 55,43
033A:  DATA 20,48
033C:  DATA 49,45
033E:  DATA 4E,20
0340:  DATA 48,54
0342:  DATA 48,4C
0344:  DATA 20,0A
0346:  DATA 00,00
0348:  DATA 41,54
034A:  DATA 2B,48
034C:  DATA 54,54
034E:  DATA 50,41
0350:  DATA 43,54
0352:  DATA 49,4F
0354:  DATA 4E,3D
0356:  DATA 30,00
0358:  DATA 54,41
035A:  DATA 54,20
035C:  DATA 47,50
035E:  DATA 52,53
0360:  DATA 0A,00
0362:  DATA 41,54
0364:  DATA 2B,53
0366:  DATA 41,50
0368:  DATA 42,52
036A:  DATA 3D,30
036C:  DATA 2C,31
036E:  DATA 00,00
0370:  DATA 63,68
0372:  DATA 75,6F
0374:  DATA 69,20
0376:  DATA 67,75
0378:  DATA 69,20
037A:  DATA 74,69
037C:  DATA 6E,3A
037E:  DATA 20,25
0380:  DATA 73,0D
0382:  DATA 0A,00
*
03AE:  TBLRD*+
03B0:  MOVF   FF5,F
03B2:  BZ    03D8
03B4:  MOVFF  FF6,2F1
03B8:  MOVFF  FF7,2F2
03BC:  CLRF   16
03BE:  BTFSC  FF2.7
03C0:  BSF    16.7
03C2:  BCF    FF2.7
03C4:  MOVFF  FF5,316
03C8:  RCALL  00C0
03CA:  BTFSC  16.7
03CC:  BSF    FF2.7
03CE:  MOVFF  2F1,FF6
03D2:  MOVFF  2F2,FF7
03D6:  BRA    03AE
03D8:  RETURN 0
03DA:  TBLRD*+
03DC:  MOVF   FF5,F
03DE:  BZ    03FA
03E0:  MOVFF  FF6,2F1
03E4:  MOVFF  FF7,2F2
03E8:  MOVF   FF5,W
03EA:  BTFSS  F9E.4
03EC:  BRA    03EA
03EE:  MOVWF  FAD
03F0:  MOVFF  2F1,FF6
03F4:  MOVFF  2F2,FF7
03F8:  BRA    03DA
03FA:  RETURN 0
*
0636:  MOVLW  8E
0638:  MOVWF  00
063A:  MOVFF  2FC,01
063E:  MOVFF  2FB,02
0642:  CLRF   03
0644:  BTFSS  01.7
0646:  BRA    0652
0648:  COMF   01,F
064A:  COMF   02,F
064C:  INCF   02,F
064E:  BNZ   0652
0650:  INCF   01,F
0652:  MOVF   01,F
0654:  BNZ   0668
0656:  MOVFF  02,01
065A:  CLRF   02
065C:  MOVLW  08
065E:  SUBWF  00,F
0660:  MOVF   01,F
0662:  BNZ   0668
0664:  CLRF   00
0666:  BRA    0682
0668:  BCF    FD8.0
066A:  BTFSC  01.7
066C:  BRA    0676
066E:  RLCF   02,F
0670:  RLCF   01,F
0672:  DECF   00,F
0674:  BRA    0668
0676:  MOVLB  2
0678:  BTFSS  xFC.7
067A:  BRA    0680
067C:  MOVLB  0
067E:  BRA    0682
0680:  BCF    01.7
0682:  MOVLB  0
0684:  GOTO   084A (RETURN)
0688:  MOVLB  3
068A:  MOVF   x02,W
068C:  BTFSC  FD8.2
068E:  BRA    07DA
0690:  MOVWF  x0E
0692:  MOVF   x06,W
0694:  BTFSC  FD8.2
0696:  BRA    07DA
0698:  SUBWF  x0E,F
069A:  BNC   06A6
069C:  MOVLW  7F
069E:  ADDWF  x0E,F
06A0:  BTFSC  FD8.0
06A2:  BRA    07DA
06A4:  BRA    06B2
06A6:  MOVLW  81
06A8:  SUBWF  x0E,F
06AA:  BTFSS  FD8.0
06AC:  BRA    07DA
06AE:  BTFSC  FD8.2
06B0:  BRA    07DA
06B2:  MOVFF  30E,00
06B6:  CLRF   01
06B8:  CLRF   02
06BA:  CLRF   03
06BC:  CLRF   x0D
06BE:  MOVFF  303,30C
06C2:  BSF    x0C.7
06C4:  MOVFF  304,30B
06C8:  MOVFF  305,30A
06CC:  MOVLW  19
06CE:  MOVWF  x0E
06D0:  MOVF   x09,W
06D2:  SUBWF  x0A,F
06D4:  BC    06F0
06D6:  MOVLW  01
06D8:  SUBWF  x0B,F
06DA:  BC    06F0
06DC:  SUBWF  x0C,F
06DE:  BC    06F0
06E0:  SUBWF  x0D,F
06E2:  BC    06F0
06E4:  INCF   x0D,F
06E6:  INCF   x0C,F
06E8:  INCF   x0B,F
06EA:  MOVF   x09,W
06EC:  ADDWF  x0A,F
06EE:  BRA    0740
06F0:  MOVF   x08,W
06F2:  SUBWF  x0B,F
06F4:  BC    071A
06F6:  MOVLW  01
06F8:  SUBWF  x0C,F
06FA:  BC    071A
06FC:  SUBWF  x0D,F
06FE:  BC    071A
0700:  INCF   x0D,F
0702:  INCF   x0C,F
0704:  MOVF   x08,W
0706:  ADDWF  x0B,F
0708:  MOVF   x09,W
070A:  ADDWF  x0A,F
070C:  BNC   0740
070E:  INCF   x0B,F
0710:  BNZ   0740
0712:  INCF   x0C,F
0714:  BNZ   0740
0716:  INCF   x0D,F
0718:  BRA    0740
071A:  MOVF   x07,W
071C:  IORLW  80
071E:  SUBWF  x0C,F
0720:  BC    073E
0722:  MOVLW  01
0724:  SUBWF  x0D,F
0726:  BC    073E
0728:  INCF   x0D,F
072A:  MOVF   x07,W
072C:  IORLW  80
072E:  ADDWF  x0C,F
0730:  MOVF   x08,W
0732:  ADDWF  x0B,F
0734:  BNC   0708
0736:  INCF   x0C,F
0738:  BNZ   0708
073A:  INCF   x0D,F
073C:  BRA    0708
073E:  BSF    03.0
0740:  DECFSZ x0E,F
0742:  BRA    0746
0744:  BRA    075C
0746:  BCF    FD8.0
0748:  RLCF   x0A,F
074A:  RLCF   x0B,F
074C:  RLCF   x0C,F
074E:  RLCF   x0D,F
0750:  BCF    FD8.0
0752:  RLCF   03,F
0754:  RLCF   02,F
0756:  RLCF   01,F
0758:  RLCF   x0F,F
075A:  BRA    06D0
075C:  BTFSS  x0F.0
075E:  BRA    076C
0760:  BCF    FD8.0
0762:  RRCF   01,F
0764:  RRCF   02,F
0766:  RRCF   03,F
0768:  RRCF   x0F,F
076A:  BRA    0770
076C:  DECF   00,F
076E:  BZ    07DA
0770:  BTFSC  x0F.7
0772:  BRA    07B0
0774:  BCF    FD8.0
0776:  RLCF   x0A,F
0778:  RLCF   x0B,F
077A:  RLCF   x0C,F
077C:  RLCF   x0D,F
077E:  MOVF   x09,W
0780:  SUBWF  x0A,F
0782:  BC    0792
0784:  MOVLW  01
0786:  SUBWF  x0B,F
0788:  BC    0792
078A:  SUBWF  x0C,F
078C:  BC    0792
078E:  SUBWF  x0D,F
0790:  BNC   07C6
0792:  MOVF   x08,W
0794:  SUBWF  x0B,F
0796:  BC    07A2
0798:  MOVLW  01
079A:  SUBWF  x0C,F
079C:  BC    07A2
079E:  SUBWF  x0D,F
07A0:  BNC   07C6
07A2:  MOVF   x07,W
07A4:  IORLW  80
07A6:  SUBWF  x0C,F
07A8:  BC    07B0
07AA:  MOVLW  01
07AC:  SUBWF  x0D,F
07AE:  BNC   07C6
07B0:  INCF   03,F
07B2:  BNZ   07C6
07B4:  INCF   02,F
07B6:  BNZ   07C6
07B8:  INCF   01,F
07BA:  BNZ   07C6
07BC:  INCF   00,F
07BE:  BZ    07DA
07C0:  RRCF   01,F
07C2:  RRCF   02,F
07C4:  RRCF   03,F
07C6:  MOVFF  303,30E
07CA:  MOVF   x07,W
07CC:  XORWF  x0E,F
07CE:  BTFSS  x0E.7
07D0:  BRA    07D6
07D2:  BSF    01.7
07D4:  BRA    07E2
07D6:  BCF    01.7
07D8:  BRA    07E2
07DA:  CLRF   00
07DC:  CLRF   01
07DE:  CLRF   02
07E0:  CLRF   03
07E2:  MOVLB  0
07E4:  RETURN 0
*
08A8:  MOVLW  8E
08AA:  MOVWF  00
08AC:  MOVLB  2
08AE:  MOVF   xF6,W
08B0:  SUBWF  00,F
08B2:  MOVFF  2F7,02
08B6:  MOVFF  2F8,01
08BA:  BSF    02.7
08BC:  MOVF   00,F
08BE:  BZ    08D2
08C0:  BCF    FD8.0
08C2:  MOVF   02,F
08C4:  BNZ   08CA
08C6:  MOVF   01,F
08C8:  BZ    08D2
08CA:  RRCF   02,F
08CC:  RRCF   01,F
08CE:  DECFSZ 00,F
08D0:  BRA    08C0
08D2:  BTFSS  xF7.7
08D4:  BRA    08E0
08D6:  COMF   01,F
08D8:  COMF   02,F
08DA:  INCF   01,F
08DC:  BTFSC  FD8.2
08DE:  INCF   02,F
08E0:  MOVLB  0
08E2:  RETURN 0
08E4:  MOVLW  8E
08E6:  MOVWF  00
08E8:  MOVFF  301,01
08EC:  MOVFF  300,02
08F0:  CLRF   03
08F2:  MOVF   01,F
08F4:  BNZ   0908
08F6:  MOVFF  02,01
08FA:  CLRF   02
08FC:  MOVLW  08
08FE:  SUBWF  00,F
0900:  MOVF   01,F
0902:  BNZ   0908
0904:  CLRF   00
0906:  BRA    0918
0908:  BCF    FD8.0
090A:  BTFSC  01.7
090C:  BRA    0916
090E:  RLCF   02,F
0910:  RLCF   01,F
0912:  DECF   00,F
0914:  BRA    0908
0916:  BCF    01.7
0918:  RETURN 0
091A:  MOVFF  303,30A
091E:  MOVLB  3
0920:  MOVF   x07,W
0922:  XORWF  x0A,F
0924:  BTFSS  x0A.7
0926:  BRA    0932
0928:  BCF    FD8.2
092A:  BCF    FD8.0
092C:  BTFSC  x03.7
092E:  BSF    FD8.0
0930:  BRA    0990
0932:  MOVFF  303,30A
0936:  MOVFF  306,30B
093A:  MOVF   x02,W
093C:  SUBWF  x0B,F
093E:  BZ    094C
0940:  BTFSS  x0A.7
0942:  BRA    0990
0944:  MOVF   FD8,W
0946:  XORLW  01
0948:  MOVWF  FD8
094A:  BRA    0990
094C:  MOVFF  307,30B
0950:  MOVF   x03,W
0952:  SUBWF  x0B,F
0954:  BZ    0962
0956:  BTFSS  x0A.7
0958:  BRA    0990
095A:  MOVF   FD8,W
095C:  XORLW  01
095E:  MOVWF  FD8
0960:  BRA    0990
0962:  MOVFF  308,30B
0966:  MOVF   x04,W
0968:  SUBWF  x0B,F
096A:  BZ    0978
096C:  BTFSS  x0A.7
096E:  BRA    0990
0970:  MOVF   FD8,W
0972:  XORLW  01
0974:  MOVWF  FD8
0976:  BRA    0990
0978:  MOVFF  309,30B
097C:  MOVF   x05,W
097E:  SUBWF  x0B,F
0980:  BZ    098E
0982:  BTFSS  x0A.7
0984:  BRA    0990
0986:  MOVF   FD8,W
0988:  XORLW  01
098A:  MOVWF  FD8
098C:  BRA    0990
098E:  BCF    FD8.0
0990:  MOVLB  0
0992:  GOTO   0E16 (RETURN)
0996:  MOVLW  80
0998:  BTFSS  FD8.1
099A:  BRA    09A0
099C:  MOVLB  3
099E:  XORWF  x07,F
09A0:  MOVLB  3
09A2:  CLRF   x0C
09A4:  CLRF   x0D
09A6:  MOVFF  303,30B
09AA:  MOVF   x07,W
09AC:  XORWF  x0B,F
09AE:  MOVF   x02,W
09B0:  BTFSC  FD8.2
09B2:  BRA    0B72
09B4:  MOVWF  x0A
09B6:  MOVWF  00
09B8:  MOVF   x06,W
09BA:  BTFSC  FD8.2
09BC:  BRA    0B84
09BE:  SUBWF  x0A,F
09C0:  BTFSC  FD8.2
09C2:  BRA    0ACA
09C4:  BNC   0A42
09C6:  MOVFF  307,310
09CA:  BSF    x10.7
09CC:  MOVFF  308,30F
09D0:  MOVFF  309,30E
09D4:  CLRF   x0D
09D6:  BCF    FD8.0
09D8:  RRCF   x10,F
09DA:  RRCF   x0F,F
09DC:  RRCF   x0E,F
09DE:  RRCF   x0D,F
09E0:  DECFSZ x0A,F
09E2:  BRA    09D4
09E4:  BTFSS  x0B.7
09E6:  BRA    09EE
09E8:  BSF    x0C.0
09EA:  BRA    0BAC
09EC:  BCF    x0C.0
09EE:  BCF    x0A.0
09F0:  BSF    x0C.4
09F2:  MOVLW  03
09F4:  MOVWF  FEA
09F6:  MOVLW  05
09F8:  MOVWF  FE9
09FA:  BRA    0BD2
09FC:  BCF    x0C.4
09FE:  BTFSC  x0B.7
0A00:  BRA    0A16
0A02:  BTFSS  x0A.0
0A04:  BRA    0A2C
0A06:  RRCF   x10,F
0A08:  RRCF   x0F,F
0A0A:  RRCF   x0E,F
0A0C:  RRCF   x0D,F
0A0E:  INCF   00,F
0A10:  BTFSC  FD8.2
0A12:  BRA    0BA2
0A14:  BRA    0A2C
0A16:  BTFSC  x10.7
0A18:  BRA    0A32
0A1A:  BCF    FD8.0
0A1C:  RLCF   x0D,F
0A1E:  RLCF   x0E,F
0A20:  RLCF   x0F,F
0A22:  RLCF   x10,F
0A24:  DECF   00,F
0A26:  BTFSC  FD8.2
0A28:  BRA    0BA2
0A2A:  BRA    0A16
0A2C:  BSF    x0C.6
0A2E:  BRA    0B0A
0A30:  BCF    x0C.6
0A32:  MOVFF  303,30B
0A36:  BTFSS  x03.7
0A38:  BRA    0A3E
0A3A:  BSF    x10.7
0A3C:  BRA    0B94
0A3E:  BCF    x10.7
0A40:  BRA    0B94
0A42:  MOVFF  306,30A
0A46:  MOVFF  306,00
0A4A:  MOVF   x02,W
0A4C:  SUBWF  x0A,F
0A4E:  MOVFF  303,310
0A52:  BSF    x10.7
0A54:  MOVFF  304,30F
0A58:  MOVFF  305,30E
0A5C:  CLRF   x0D
0A5E:  BCF    FD8.0
0A60:  RRCF   x10,F
0A62:  RRCF   x0F,F
0A64:  RRCF   x0E,F
0A66:  RRCF   x0D,F
0A68:  DECFSZ x0A,F
0A6A:  BRA    0A5C
0A6C:  BTFSS  x0B.7
0A6E:  BRA    0A76
0A70:  BSF    x0C.1
0A72:  BRA    0BAC
0A74:  BCF    x0C.1
0A76:  BCF    x0A.0
0A78:  BSF    x0C.5
0A7A:  MOVLW  03
0A7C:  MOVWF  FEA
0A7E:  MOVLW  09
0A80:  MOVWF  FE9
0A82:  BRA    0BD2
0A84:  BCF    x0C.5
0A86:  BTFSC  x0B.7
0A88:  BRA    0A9E
0A8A:  BTFSS  x0A.0
0A8C:  BRA    0AB4
0A8E:  RRCF   x10,F
0A90:  RRCF   x0F,F
0A92:  RRCF   x0E,F
0A94:  RRCF   x0D,F
0A96:  INCF   00,F
0A98:  BTFSC  FD8.2
0A9A:  BRA    0BA2
0A9C:  BRA    0AB4
0A9E:  BTFSC  x10.7
0AA0:  BRA    0ABA
0AA2:  BCF    FD8.0
0AA4:  RLCF   x0D,F
0AA6:  RLCF   x0E,F
0AA8:  RLCF   x0F,F
0AAA:  RLCF   x10,F
0AAC:  DECF   00,F
0AAE:  BTFSC  FD8.2
0AB0:  BRA    0BA2
0AB2:  BRA    0A9E
0AB4:  BSF    x0C.7
0AB6:  BRA    0B0A
0AB8:  BCF    x0C.7
0ABA:  MOVFF  307,30B
0ABE:  BTFSS  x07.7
0AC0:  BRA    0AC6
0AC2:  BSF    x10.7
0AC4:  BRA    0B94
0AC6:  BCF    x10.7
0AC8:  BRA    0B94
0ACA:  MOVFF  307,310
0ACE:  BSF    x10.7
0AD0:  MOVFF  308,30F
0AD4:  MOVFF  309,30E
0AD8:  BTFSS  x0B.7
0ADA:  BRA    0AE4
0ADC:  BCF    x10.7
0ADE:  BSF    x0C.2
0AE0:  BRA    0BAC
0AE2:  BCF    x0C.2
0AE4:  CLRF   x0D
0AE6:  BCF    x0A.0
0AE8:  MOVLW  03
0AEA:  MOVWF  FEA
0AEC:  MOVLW  05
0AEE:  MOVWF  FE9
0AF0:  BRA    0BD2
0AF2:  BTFSC  x0B.7
0AF4:  BRA    0B2E
0AF6:  MOVFF  303,30B
0AFA:  BTFSS  x0A.0
0AFC:  BRA    0B0A
0AFE:  RRCF   x10,F
0B00:  RRCF   x0F,F
0B02:  RRCF   x0E,F
0B04:  RRCF   x0D,F
0B06:  INCF   00,F
0B08:  BZ    0BA2
0B0A:  BTFSS  x0D.7
0B0C:  BRA    0B24
0B0E:  INCF   x0E,F
0B10:  BNZ   0B24
0B12:  INCF   x0F,F
0B14:  BNZ   0B24
0B16:  INCF   x10,F
0B18:  BNZ   0B24
0B1A:  RRCF   x10,F
0B1C:  RRCF   x0F,F
0B1E:  RRCF   x0E,F
0B20:  INCF   00,F
0B22:  BZ    0BA2
0B24:  BTFSC  x0C.6
0B26:  BRA    0A30
0B28:  BTFSC  x0C.7
0B2A:  BRA    0AB8
0B2C:  BRA    0B66
0B2E:  MOVLW  80
0B30:  XORWF  x10,F
0B32:  BTFSS  x10.7
0B34:  BRA    0B3E
0B36:  BRA    0BAC
0B38:  MOVFF  307,30B
0B3C:  BRA    0B52
0B3E:  MOVFF  303,30B
0B42:  MOVF   x10,F
0B44:  BNZ   0B52
0B46:  MOVF   x0F,F
0B48:  BNZ   0B52
0B4A:  MOVF   x0E,F
0B4C:  BNZ   0B52
0B4E:  CLRF   00
0B50:  BRA    0B94
0B52:  BTFSC  x10.7
0B54:  BRA    0B66
0B56:  BCF    FD8.0
0B58:  RLCF   x0D,F
0B5A:  RLCF   x0E,F
0B5C:  RLCF   x0F,F
0B5E:  RLCF   x10,F
0B60:  DECFSZ 00,F
0B62:  BRA    0B52
0B64:  BRA    0BA2
0B66:  BTFSS  x0B.7
0B68:  BRA    0B6E
0B6A:  BSF    x10.7
0B6C:  BRA    0B94
0B6E:  BCF    x10.7
0B70:  BRA    0B94
0B72:  MOVFF  306,00
0B76:  MOVFF  307,310
0B7A:  MOVFF  308,30F
0B7E:  MOVFF  309,30E
0B82:  BRA    0B94
0B84:  MOVFF  302,00
0B88:  MOVFF  303,310
0B8C:  MOVFF  304,30F
0B90:  MOVFF  305,30E
0B94:  MOVFF  310,01
0B98:  MOVFF  30F,02
0B9C:  MOVFF  30E,03
0BA0:  BRA    0C0A
0BA2:  CLRF   00
0BA4:  CLRF   01
0BA6:  CLRF   02
0BA8:  CLRF   03
0BAA:  BRA    0C0A
0BAC:  CLRF   x0D
0BAE:  COMF   x0E,F
0BB0:  COMF   x0F,F
0BB2:  COMF   x10,F
0BB4:  COMF   x0D,F
0BB6:  INCF   x0D,F
0BB8:  BNZ   0BC4
0BBA:  INCF   x0E,F
0BBC:  BNZ   0BC4
0BBE:  INCF   x0F,F
0BC0:  BNZ   0BC4
0BC2:  INCF   x10,F
0BC4:  BTFSC  x0C.0
0BC6:  BRA    09EC
0BC8:  BTFSC  x0C.1
0BCA:  BRA    0A74
0BCC:  BTFSC  x0C.2
0BCE:  BRA    0AE2
0BD0:  BRA    0B38
0BD2:  MOVF   FEF,W
0BD4:  ADDWF  x0E,F
0BD6:  BNC   0BE2
0BD8:  INCF   x0F,F
0BDA:  BNZ   0BE2
0BDC:  INCF   x10,F
0BDE:  BTFSC  FD8.2
0BE0:  BSF    x0A.0
0BE2:  MOVF   FED,F
0BE4:  MOVF   FEF,W
0BE6:  ADDWF  x0F,F
0BE8:  BNC   0BF0
0BEA:  INCF   x10,F
0BEC:  BTFSC  FD8.2
0BEE:  BSF    x0A.0
0BF0:  MOVF   FED,F
0BF2:  MOVF   FEF,W
0BF4:  BTFSC  FEF.7
0BF6:  BRA    0BFA
0BF8:  XORLW  80
0BFA:  ADDWF  x10,F
0BFC:  BTFSC  FD8.0
0BFE:  BSF    x0A.0
0C00:  BTFSC  x0C.4
0C02:  BRA    09FC
0C04:  BTFSC  x0C.5
0C06:  BRA    0A84
0C08:  BRA    0AF2
0C0A:  MOVLB  0
0C0C:  RETURN 0
0C0E:  MOVLB  2
0C10:  MOVF   xFE,W
0C12:  BTFSC  FD8.2
0C14:  BRA    0D22
0C16:  MOVWF  00
0C18:  MOVLB  3
0C1A:  MOVF   x02,W
0C1C:  BTFSS  FD8.2
0C1E:  BRA    0C24
0C20:  MOVLB  2
0C22:  BRA    0D22
0C24:  ADDWF  00,F
0C26:  BNC   0C36
0C28:  MOVLW  81
0C2A:  ADDWF  00,F
0C2C:  BTFSS  FD8.0
0C2E:  BRA    0C34
0C30:  MOVLB  2
0C32:  BRA    0D22
0C34:  BRA    0C4A
0C36:  MOVLW  7F
0C38:  SUBWF  00,F
0C3A:  BTFSC  FD8.0
0C3C:  BRA    0C42
0C3E:  MOVLB  2
0C40:  BRA    0D22
0C42:  BTFSS  FD8.2
0C44:  BRA    0C4A
0C46:  MOVLB  2
0C48:  BRA    0D22
0C4A:  MOVFF  2FF,306
0C4E:  MOVF   x03,W
0C50:  XORWF  x06,F
0C52:  MOVLB  2
0C54:  BSF    xFF.7
0C56:  MOVLB  3
0C58:  BSF    x03.7
0C5A:  MOVF   x01,W
0C5C:  MULWF  x05
0C5E:  MOVFF  FF4,308
0C62:  MOVF   x00,W
0C64:  MULWF  x04
0C66:  MOVFF  FF4,03
0C6A:  MOVFF  FF3,307
0C6E:  MULWF  x05
0C70:  MOVF   FF3,W
0C72:  ADDWF  x08,F
0C74:  MOVF   FF4,W
0C76:  ADDWFC x07,F
0C78:  MOVLW  00
0C7A:  ADDWFC 03,F
0C7C:  MOVF   x01,W
0C7E:  MULWF  x04
0C80:  MOVF   FF3,W
0C82:  ADDWF  x08,F
0C84:  MOVF   FF4,W
0C86:  ADDWFC x07,F
0C88:  MOVLW  00
0C8A:  CLRF   02
0C8C:  ADDWFC 03,F
0C8E:  ADDWFC 02,F
0C90:  MOVLB  2
0C92:  MOVF   xFF,W
0C94:  MOVLB  3
0C96:  MULWF  x05
0C98:  MOVF   FF3,W
0C9A:  ADDWF  x07,F
0C9C:  MOVF   FF4,W
0C9E:  ADDWFC 03,F
0CA0:  MOVLW  00
0CA2:  ADDWFC 02,F
0CA4:  MOVLB  2
0CA6:  MOVF   xFF,W
0CA8:  MOVLB  3
0CAA:  MULWF  x04
0CAC:  MOVF   FF3,W
0CAE:  ADDWF  03,F
0CB0:  MOVF   FF4,W
0CB2:  ADDWFC 02,F
0CB4:  MOVLW  00
0CB6:  CLRF   01
0CB8:  ADDWFC 01,F
0CBA:  MOVF   x01,W
0CBC:  MULWF  x03
0CBE:  MOVF   FF3,W
0CC0:  ADDWF  x07,F
0CC2:  MOVF   FF4,W
0CC4:  ADDWFC 03,F
0CC6:  MOVLW  00
0CC8:  ADDWFC 02,F
0CCA:  ADDWFC 01,F
0CCC:  MOVF   x00,W
0CCE:  MULWF  x03
0CD0:  MOVF   FF3,W
0CD2:  ADDWF  03,F
0CD4:  MOVF   FF4,W
0CD6:  ADDWFC 02,F
0CD8:  MOVLW  00
0CDA:  ADDWFC 01,F
0CDC:  MOVLB  2
0CDE:  MOVF   xFF,W
0CE0:  MOVLB  3
0CE2:  MULWF  x03
0CE4:  MOVF   FF3,W
0CE6:  ADDWF  02,F
0CE8:  MOVF   FF4,W
0CEA:  ADDWFC 01,F
0CEC:  INCF   00,F
0CEE:  BTFSC  01.7
0CF0:  BRA    0CFC
0CF2:  RLCF   x07,F
0CF4:  RLCF   03,F
0CF6:  RLCF   02,F
0CF8:  RLCF   01,F
0CFA:  DECF   00,F
0CFC:  MOVLW  00
0CFE:  BTFSS  x07.7
0D00:  BRA    0D16
0D02:  INCF   03,F
0D04:  ADDWFC 02,F
0D06:  ADDWFC 01,F
0D08:  MOVF   01,W
0D0A:  BNZ   0D16
0D0C:  MOVF   02,W
0D0E:  BNZ   0D16
0D10:  MOVF   03,W
0D12:  BNZ   0D16
0D14:  INCF   00,F
0D16:  BTFSC  x06.7
0D18:  BSF    01.7
0D1A:  BTFSS  x06.7
0D1C:  BCF    01.7
0D1E:  BRA    0D2C
0D20:  MOVLB  2
0D22:  CLRF   00
0D24:  CLRF   01
0D26:  CLRF   02
0D28:  CLRF   03
0D2A:  MOVLB  3
0D2C:  MOVLB  0
0D2E:  RETURN 0
*
1B5A:  TBLRD*+
1B5C:  MOVFF  FF6,2F2
1B60:  MOVFF  FF7,2F3
1B64:  CLRF   16
1B66:  BTFSC  FF2.7
1B68:  BSF    16.7
1B6A:  BCF    FF2.7
1B6C:  MOVFF  FF5,316
1B70:  CALL   00C0
1B74:  BTFSC  16.7
1B76:  BSF    FF2.7
1B78:  MOVFF  2F2,FF6
1B7C:  MOVFF  2F3,FF7
1B80:  MOVLB  2
1B82:  DECFSZ xF1,F
1B84:  BRA    1B88
1B86:  BRA    1B8C
1B88:  MOVLB  0
1B8A:  BRA    1B5A
1B8C:  MOVLB  0
1B8E:  RETURN 0
1B90:  MOVLB  2
1B92:  MOVF   xFE,W
1B94:  SUBLW  B6
1B96:  MOVWF  xFE
1B98:  CLRF   03
1B9A:  MOVFF  2FF,302
1B9E:  BSF    xFF.7
1BA0:  BCF    FD8.0
1BA2:  RRCF   xFF,F
1BA4:  MOVLB  3
1BA6:  RRCF   x00,F
1BA8:  RRCF   x01,F
1BAA:  RRCF   03,F
1BAC:  RRCF   02,F
1BAE:  RRCF   01,F
1BB0:  RRCF   00,F
1BB2:  MOVLB  2
1BB4:  DECFSZ xFE,F
1BB6:  BRA    1BA0
1BB8:  MOVLB  3
1BBA:  BTFSS  x02.7
1BBC:  BRA    1BD4
1BBE:  COMF   00,F
1BC0:  COMF   01,F
1BC2:  COMF   02,F
1BC4:  COMF   03,F
1BC6:  INCF   00,F
1BC8:  BTFSC  FD8.2
1BCA:  INCF   01,F
1BCC:  BTFSC  FD8.2
1BCE:  INCF   02,F
1BD0:  BTFSC  FD8.2
1BD2:  INCF   03,F
1BD4:  MOVLB  0
1BD6:  RETURN 0
1BD8:  BTFSC  FD8.1
1BDA:  BRA    1BE4
1BDC:  MOVLW  03
1BDE:  MOVWF  FEA
1BE0:  MOVLW  06
1BE2:  MOVWF  FE9
1BE4:  CLRF   00
1BE6:  CLRF   01
1BE8:  CLRF   02
1BEA:  CLRF   03
1BEC:  MOVLB  3
1BEE:  CLRF   x06
1BF0:  CLRF   x07
1BF2:  CLRF   x08
1BF4:  CLRF   x09
1BF6:  MOVF   x05,W
1BF8:  IORWF  x04,W
1BFA:  IORWF  x03,W
1BFC:  IORWF  x02,W
1BFE:  BZ    1C5C
1C00:  MOVLW  20
1C02:  MOVWF  x0A
1C04:  BCF    FD8.0
1C06:  MOVLB  2
1C08:  RLCF   xFE,F
1C0A:  RLCF   xFF,F
1C0C:  MOVLB  3
1C0E:  RLCF   x00,F
1C10:  RLCF   x01,F
1C12:  RLCF   x06,F
1C14:  RLCF   x07,F
1C16:  RLCF   x08,F
1C18:  RLCF   x09,F
1C1A:  MOVF   x05,W
1C1C:  SUBWF  x09,W
1C1E:  BNZ   1C30
1C20:  MOVF   x04,W
1C22:  SUBWF  x08,W
1C24:  BNZ   1C30
1C26:  MOVF   x03,W
1C28:  SUBWF  x07,W
1C2A:  BNZ   1C30
1C2C:  MOVF   x02,W
1C2E:  SUBWF  x06,W
1C30:  BNC   1C50
1C32:  MOVF   x02,W
1C34:  SUBWF  x06,F
1C36:  MOVF   x03,W
1C38:  BTFSS  FD8.0
1C3A:  INCFSZ x03,W
1C3C:  SUBWF  x07,F
1C3E:  MOVF   x04,W
1C40:  BTFSS  FD8.0
1C42:  INCFSZ x04,W
1C44:  SUBWF  x08,F
1C46:  MOVF   x05,W
1C48:  BTFSS  FD8.0
1C4A:  INCFSZ x05,W
1C4C:  SUBWF  x09,F
1C4E:  BSF    FD8.0
1C50:  RLCF   00,F
1C52:  RLCF   01,F
1C54:  RLCF   02,F
1C56:  RLCF   03,F
1C58:  DECFSZ x0A,F
1C5A:  BRA    1C04
1C5C:  MOVFF  306,FEF
1C60:  MOVFF  307,FEC
1C64:  MOVFF  308,FEC
1C68:  MOVFF  309,FEC
1C6C:  MOVLB  0
1C6E:  RETURN 0
1C70:  MOVF   FE9,W
1C72:  MOVLB  2
1C74:  MOVWF  xF6
1C76:  MOVF   xF5,W
1C78:  MOVWF  xF8
1C7A:  BZ    1CB6
1C7C:  MOVFF  2F4,301
1C80:  MOVFF  2F3,300
1C84:  MOVFF  2F2,2FF
1C88:  MOVFF  2F1,2FE
1C8C:  MOVLB  3
1C8E:  CLRF   x05
1C90:  CLRF   x04
1C92:  MOVLW  20
1C94:  MOVWF  x03
1C96:  MOVLW  82
1C98:  MOVWF  x02
1C9A:  MOVLB  0
1C9C:  CALL   0C0E
1CA0:  MOVFF  03,2F4
1CA4:  MOVFF  02,2F3
1CA8:  MOVFF  01,2F2
1CAC:  MOVFF  00,2F1
1CB0:  MOVLB  2
1CB2:  DECFSZ xF8,F
1CB4:  BRA    1C7C
1CB6:  MOVFF  2F4,301
1CBA:  MOVFF  2F3,300
1CBE:  MOVFF  2F2,2FF
1CC2:  MOVFF  2F1,2FE
1CC6:  MOVLB  0
1CC8:  RCALL  1B90
1CCA:  MOVFF  03,2F4
1CCE:  MOVFF  02,2F3
1CD2:  MOVFF  01,2F2
1CD6:  MOVFF  00,2F1
1CDA:  MOVLB  2
1CDC:  BTFSS  xF4.7
1CDE:  BRA    1CFA
1CE0:  DECF   xF6,F
1CE2:  BSF    xF6.5
1CE4:  COMF   xF1,F
1CE6:  COMF   xF2,F
1CE8:  COMF   xF3,F
1CEA:  COMF   xF4,F
1CEC:  INCF   xF1,F
1CEE:  BTFSC  FD8.2
1CF0:  INCF   xF2,F
1CF2:  BTFSC  FD8.2
1CF4:  INCF   xF3,F
1CF6:  BTFSC  FD8.2
1CF8:  INCF   xF4,F
1CFA:  MOVLW  3B
1CFC:  MOVWF  xFD
1CFE:  MOVLW  9A
1D00:  MOVWF  xFC
1D02:  MOVLW  CA
1D04:  MOVWF  xFB
1D06:  CLRF   xFA
1D08:  MOVLW  0A
1D0A:  MOVWF  xF8
1D0C:  MOVF   xF5,W
1D0E:  BTFSC  FD8.2
1D10:  INCF   xF6,F
1D12:  BSF    FD8.1
1D14:  MOVLW  02
1D16:  MOVWF  FEA
1D18:  MOVLW  F1
1D1A:  MOVWF  FE9
1D1C:  MOVFF  2F4,301
1D20:  MOVFF  2F3,300
1D24:  MOVFF  2F2,2FF
1D28:  MOVFF  2F1,2FE
1D2C:  MOVFF  2FD,305
1D30:  MOVFF  2FC,304
1D34:  MOVFF  2FB,303
1D38:  MOVFF  2FA,302
1D3C:  MOVLB  0
1D3E:  RCALL  1BD8
1D40:  MOVF   01,W
1D42:  MOVF   00,F
1D44:  BNZ   1D6C
1D46:  MOVLB  2
1D48:  INCF   xF5,W
1D4A:  SUBWF  xF8,W
1D4C:  BTFSS  FD8.2
1D4E:  BRA    1D54
1D50:  MOVLB  0
1D52:  BRA    1D6C
1D54:  MOVF   xF6,W
1D56:  BZ    1D72
1D58:  ANDLW  0F
1D5A:  SUBWF  xF8,W
1D5C:  BZ    1D60
1D5E:  BC    1E1E
1D60:  BTFSC  xF6.7
1D62:  BRA    1E1E
1D64:  BTFSC  xF6.6
1D66:  BRA    1D72
1D68:  MOVLW  20
1D6A:  BRA    1E04
1D6C:  MOVLW  20
1D6E:  MOVLB  2
1D70:  ANDWF  xF6,F
1D72:  BTFSS  xF6.5
1D74:  BRA    1DA2
1D76:  BCF    xF6.5
1D78:  MOVF   xF5,W
1D7A:  BTFSS  FD8.2
1D7C:  DECF   xF6,F
1D7E:  MOVF   00,W
1D80:  MOVWF  xF6
1D82:  CLRF   16
1D84:  BTFSC  FF2.7
1D86:  BSF    16.7
1D88:  BCF    FF2.7
1D8A:  MOVLW  2D
1D8C:  MOVLB  3
1D8E:  MOVWF  x16
1D90:  MOVLB  0
1D92:  CALL   00C0
1D96:  BTFSC  16.7
1D98:  BSF    FF2.7
1D9A:  MOVLB  2
1D9C:  MOVF   xF6,W
1D9E:  MOVWF  00
1DA0:  CLRF   xF6
1DA2:  MOVF   xF5,W
1DA4:  SUBWF  xF8,W
1DA6:  BNZ   1DD0
1DA8:  MOVF   00,W
1DAA:  MOVWF  xF6
1DAC:  CLRF   16
1DAE:  BTFSC  FF2.7
1DB0:  BSF    16.7
1DB2:  BCF    FF2.7
1DB4:  MOVLW  2E
1DB6:  MOVLB  3
1DB8:  MOVWF  x16
1DBA:  MOVLB  0
1DBC:  CALL   00C0
1DC0:  BTFSC  16.7
1DC2:  BSF    FF2.7
1DC4:  MOVLB  2
1DC6:  MOVF   xF6,W
1DC8:  MOVWF  00
1DCA:  MOVLW  20
1DCC:  ANDWF  xF6,F
1DCE:  MOVLW  00
1DD0:  MOVLW  30
1DD2:  BTFSS  xF6.5
1DD4:  BRA    1E04
1DD6:  BCF    xF6.5
1DD8:  MOVF   xF5,W
1DDA:  BTFSS  FD8.2
1DDC:  DECF   xF6,F
1DDE:  MOVF   00,W
1DE0:  MOVWF  xF6
1DE2:  CLRF   16
1DE4:  BTFSC  FF2.7
1DE6:  BSF    16.7
1DE8:  BCF    FF2.7
1DEA:  MOVLW  2D
1DEC:  MOVLB  3
1DEE:  MOVWF  x16
1DF0:  MOVLB  0
1DF2:  CALL   00C0
1DF6:  BTFSC  16.7
1DF8:  BSF    FF2.7
1DFA:  MOVLB  2
1DFC:  MOVF   xF6,W
1DFE:  MOVWF  00
1E00:  CLRF   xF6
1E02:  MOVLW  30
1E04:  ADDWF  00,F
1E06:  CLRF   16
1E08:  BTFSC  FF2.7
1E0A:  BSF    16.7
1E0C:  BCF    FF2.7
1E0E:  MOVFF  00,316
1E12:  MOVLB  0
1E14:  CALL   00C0
1E18:  BTFSC  16.7
1E1A:  BSF    FF2.7
1E1C:  MOVLB  2
1E1E:  BCF    FD8.1
1E20:  MOVFF  2FD,301
1E24:  MOVFF  2FC,300
1E28:  MOVFF  2FB,2FF
1E2C:  MOVFF  2FA,2FE
1E30:  MOVLB  3
1E32:  CLRF   x05
1E34:  CLRF   x04
1E36:  CLRF   x03
1E38:  MOVLW  0A
1E3A:  MOVWF  x02
1E3C:  MOVLB  0
1E3E:  RCALL  1BD8
1E40:  MOVFF  03,2FD
1E44:  MOVFF  02,2FC
1E48:  MOVFF  01,2FB
1E4C:  MOVFF  00,2FA
1E50:  MOVLB  2
1E52:  DECFSZ xF8,F
1E54:  BRA    1D12
1E56:  MOVLB  0
1E58:  RETURN 0
1E5A:  MOVFF  2F0,FEA
1E5E:  MOVFF  2EF,FE9
1E62:  MOVLB  2
1E64:  MOVFF  2FE,FEF
1E68:  INCF   FE9,F
1E6A:  BTFSC  FD8.2
1E6C:  INCF   FEA,F
1E6E:  CLRF   FEF
1E70:  INCF   xEF,F
1E72:  BTFSC  FD8.2
1E74:  INCF   xF0,F
1E76:  MOVLB  0
1E78:  RETURN 0
1E7A:  TBLRD*+
1E7C:  MOVFF  FF6,2F2
1E80:  MOVFF  FF7,2F3
1E84:  MOVFF  FF5,2FE
1E88:  RCALL  1E5A
1E8A:  MOVFF  2F2,FF6
1E8E:  MOVFF  2F3,FF7
1E92:  MOVLB  2
1E94:  DECFSZ xF1,F
1E96:  BRA    1E9A
1E98:  BRA    1E9E
1E9A:  MOVLB  0
1E9C:  BRA    1E7A
1E9E:  MOVLB  0
1EA0:  RETURN 0
1EA2:  MOVF   FE9,W
1EA4:  MOVLB  2
1EA6:  MOVWF  xF6
1EA8:  MOVF   xF5,W
1EAA:  MOVWF  xF8
1EAC:  BZ    1EE8
1EAE:  MOVFF  2F4,301
1EB2:  MOVFF  2F3,300
1EB6:  MOVFF  2F2,2FF
1EBA:  MOVFF  2F1,2FE
1EBE:  MOVLB  3
1EC0:  CLRF   x05
1EC2:  CLRF   x04
1EC4:  MOVLW  20
1EC6:  MOVWF  x03
1EC8:  MOVLW  82
1ECA:  MOVWF  x02
1ECC:  MOVLB  0
1ECE:  CALL   0C0E
1ED2:  MOVFF  03,2F4
1ED6:  MOVFF  02,2F3
1EDA:  MOVFF  01,2F2
1EDE:  MOVFF  00,2F1
1EE2:  MOVLB  2
1EE4:  DECFSZ xF8,F
1EE6:  BRA    1EAE
1EE8:  MOVFF  2F4,301
1EEC:  MOVFF  2F3,300
1EF0:  MOVFF  2F2,2FF
1EF4:  MOVFF  2F1,2FE
1EF8:  MOVLB  0
1EFA:  RCALL  1B90
1EFC:  MOVFF  03,2F4
1F00:  MOVFF  02,2F3
1F04:  MOVFF  01,2F2
1F08:  MOVFF  00,2F1
1F0C:  MOVLB  2
1F0E:  BTFSS  xF4.7
1F10:  BRA    1F2C
1F12:  DECF   xF6,F
1F14:  BSF    xF6.5
1F16:  COMF   xF1,F
1F18:  COMF   xF2,F
1F1A:  COMF   xF3,F
1F1C:  COMF   xF4,F
1F1E:  INCF   xF1,F
1F20:  BTFSC  FD8.2
1F22:  INCF   xF2,F
1F24:  BTFSC  FD8.2
1F26:  INCF   xF3,F
1F28:  BTFSC  FD8.2
1F2A:  INCF   xF4,F
1F2C:  MOVLW  3B
1F2E:  MOVWF  xFD
1F30:  MOVLW  9A
1F32:  MOVWF  xFC
1F34:  MOVLW  CA
1F36:  MOVWF  xFB
1F38:  CLRF   xFA
1F3A:  MOVLW  0A
1F3C:  MOVWF  xF8
1F3E:  MOVF   xF5,W
1F40:  BTFSC  FD8.2
1F42:  INCF   xF6,F
1F44:  BSF    FD8.1
1F46:  MOVLW  02
1F48:  MOVWF  FEA
1F4A:  MOVLW  F1
1F4C:  MOVWF  FE9
1F4E:  MOVFF  2F4,301
1F52:  MOVFF  2F3,300
1F56:  MOVFF  2F2,2FF
1F5A:  MOVFF  2F1,2FE
1F5E:  MOVFF  2FD,305
1F62:  MOVFF  2FC,304
1F66:  MOVFF  2FB,303
1F6A:  MOVFF  2FA,302
1F6E:  MOVLB  0
1F70:  RCALL  1BD8
1F72:  MOVF   01,W
1F74:  MOVF   00,F
1F76:  BNZ   1F9E
1F78:  MOVLB  2
1F7A:  INCF   xF5,W
1F7C:  SUBWF  xF8,W
1F7E:  BTFSS  FD8.2
1F80:  BRA    1F86
1F82:  MOVLB  0
1F84:  BRA    1F9E
1F86:  MOVF   xF6,W
1F88:  BZ    1FA4
1F8A:  ANDLW  0F
1F8C:  SUBWF  xF8,W
1F8E:  BZ    1F92
1F90:  BC    2012
1F92:  BTFSC  xF6.7
1F94:  BRA    2012
1F96:  BTFSC  xF6.6
1F98:  BRA    1FA4
1F9A:  MOVLW  20
1F9C:  BRA    2006
1F9E:  MOVLW  20
1FA0:  MOVLB  2
1FA2:  ANDWF  xF6,F
1FA4:  BTFSS  xF6.5
1FA6:  BRA    1FC4
1FA8:  BCF    xF6.5
1FAA:  MOVF   xF5,W
1FAC:  BTFSS  FD8.2
1FAE:  DECF   xF6,F
1FB0:  MOVF   00,W
1FB2:  MOVWF  xF6
1FB4:  MOVLW  2D
1FB6:  MOVWF  xFE
1FB8:  MOVLB  0
1FBA:  RCALL  1E5A
1FBC:  MOVLB  2
1FBE:  MOVF   xF6,W
1FC0:  MOVWF  00
1FC2:  CLRF   xF6
1FC4:  MOVF   xF5,W
1FC6:  SUBWF  xF8,W
1FC8:  BNZ   1FE2
1FCA:  MOVF   00,W
1FCC:  MOVWF  xF6
1FCE:  MOVLW  2E
1FD0:  MOVWF  xFE
1FD2:  MOVLB  0
1FD4:  RCALL  1E5A
1FD6:  MOVLB  2
1FD8:  MOVF   xF6,W
1FDA:  MOVWF  00
1FDC:  MOVLW  20
1FDE:  ANDWF  xF6,F
1FE0:  MOVLW  00
1FE2:  MOVLW  30
1FE4:  BTFSS  xF6.5
1FE6:  BRA    2006
1FE8:  BCF    xF6.5
1FEA:  MOVF   xF5,W
1FEC:  BTFSS  FD8.2
1FEE:  DECF   xF6,F
1FF0:  MOVF   00,W
1FF2:  MOVWF  xF6
1FF4:  MOVLW  2D
1FF6:  MOVWF  xFE
1FF8:  MOVLB  0
1FFA:  RCALL  1E5A
1FFC:  MOVLB  2
1FFE:  MOVF   xF6,W
2000:  MOVWF  00
2002:  CLRF   xF6
2004:  MOVLW  30
2006:  ADDWF  00,F
2008:  MOVFF  00,2FE
200C:  MOVLB  0
200E:  RCALL  1E5A
2010:  MOVLB  2
2012:  BCF    FD8.1
2014:  MOVFF  2FD,301
2018:  MOVFF  2FC,300
201C:  MOVFF  2FB,2FF
2020:  MOVFF  2FA,2FE
2024:  MOVLB  3
2026:  CLRF   x05
2028:  CLRF   x04
202A:  CLRF   x03
202C:  MOVLW  0A
202E:  MOVWF  x02
2030:  MOVLB  0
2032:  RCALL  1BD8
2034:  MOVFF  03,2FD
2038:  MOVFF  02,2FC
203C:  MOVFF  01,2FB
2040:  MOVFF  00,2FA
2044:  MOVLB  2
2046:  DECFSZ xF8,F
2048:  BRA    1F44
204A:  MOVLB  0
204C:  RETURN 0
204E:  MOVF   FEF,F
2050:  BZ    207E
2052:  MOVFF  FEA,2F2
2056:  MOVFF  FE9,2F1
205A:  CLRF   16
205C:  BTFSC  FF2.7
205E:  BSF    16.7
2060:  BCF    FF2.7
2062:  MOVFF  FEF,316
2066:  CALL   00C0
206A:  BTFSC  16.7
206C:  BSF    FF2.7
206E:  MOVFF  2F2,FEA
2072:  MOVFF  2F1,FE9
2076:  INCF   FE9,F
2078:  BTFSC  FD8.2
207A:  INCF   FEA,F
207C:  BRA    204E
207E:  GOTO   2244 (RETURN)
2082:  MOVF   FEF,F
2084:  BZ    20A6
2086:  MOVFF  FEA,2F2
208A:  MOVFF  FE9,2F1
208E:  MOVF   FEF,W
2090:  BTFSS  F9E.4
2092:  BRA    2090
2094:  MOVWF  FAD
2096:  MOVFF  2F2,FEA
209A:  MOVFF  2F1,FE9
209E:  INCF   FE9,F
20A0:  BTFSC  FD8.2
20A2:  INCF   FEA,F
20A4:  BRA    2082
20A6:  GOTO   224C (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE *=16 ADC=10 
.................... #device PASS_STRINGS = IN_RAM  
.................... #fuses HSPLL,MCLR,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN                  
.................... #use delay(clock=48000000)  
*
0384:  MOVLW  02
0386:  MOVWF  FEA
0388:  MOVLW  FE
038A:  MOVWF  FE9
038C:  MOVF   FEF,W
038E:  BZ    03AC
0390:  MOVLW  0F
0392:  MOVWF  01
0394:  CLRF   00
0396:  DECFSZ 00,F
0398:  BRA    0396
039A:  DECFSZ 01,F
039C:  BRA    0394
039E:  MOVLW  8F
03A0:  MOVWF  00
03A2:  DECFSZ 00,F
03A4:  BRA    03A2
03A6:  NOP   
03A8:  DECFSZ FEF,F
03AA:  BRA    0390
03AC:  RETURN 0
*
0552:  MOVLW  01
0554:  MOVLB  2
0556:  SUBWF  xFD,F
0558:  BNC   0574
055A:  MOVLW  02
055C:  MOVWF  FEA
055E:  MOVLW  FD
0560:  MOVWF  FE9
0562:  MOVF   FEF,W
0564:  BZ    0574
0566:  MOVLW  02
0568:  MOVWF  00
056A:  DECFSZ 00,F
056C:  BRA    056A
056E:  BRA    0570
0570:  DECFSZ FEF,F
0572:  BRA    0566
0574:  MOVLB  0
0576:  RETURN 0
....................  
.................... #use rs232(parity=N,xmit = PIN_D4, rcv = PIN_C4, baud = 9600,stream=UART1) 
*
00C0:  BCF    F95.4
00C2:  BCF    F8C.4
00C4:  MOVLW  08
00C6:  MOVWF  01
00C8:  BRA    00CA
00CA:  NOP   
00CC:  BSF    01.7
00CE:  BRA    00F0
00D0:  BCF    01.7
00D2:  MOVLB  3
00D4:  RRCF   x16,F
00D6:  MOVLB  0
00D8:  BTFSC  FD8.0
00DA:  BSF    F8C.4
00DC:  BTFSS  FD8.0
00DE:  BCF    F8C.4
00E0:  BSF    01.6
00E2:  BRA    00F0
00E4:  BCF    01.6
00E6:  DECFSZ 01,F
00E8:  BRA    00D2
00EA:  BRA    00EC
00EC:  NOP   
00EE:  BSF    F8C.4
00F0:  MOVLW  01
00F2:  MOVWF  00
00F4:  CLRF   FE9
00F6:  DECFSZ FE9,F
00F8:  BRA    00F6
00FA:  DECFSZ 00,F
00FC:  BRA    00F4
00FE:  MOVLW  99
0100:  MOVWF  FE9
0102:  DECFSZ FE9,F
0104:  BRA    0102
0106:  NOP   
0108:  BTFSC  01.7
010A:  BRA    00D0
010C:  BTFSC  01.6
010E:  BRA    00E4
0110:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=UARTSIM)  
*
03FC:  BTFSS  F9E.4
03FE:  BRA    03FC
0400:  MOVWF  FAD
0402:  RETURN 0
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "TV_1wire.c" 
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C 
....................    
.................... /* 
....................  * One wire (1-wire) driver for CCS C compiler. Suitable for use with devices 
....................  * such as the DS18B20 1-wire digital temperature sensor. 
....................  */ 
....................    
.................... #define ONE_WIRE_PIN PIN_E0 
....................    
.................... /* 
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus. 
....................  */ 
.................... // OK if just using a single permanently connected device 
.................... void onewire_reset() { 
....................     output_low(ONE_WIRE_PIN);       // pull the bus low for reset 
*
0578:  BCF    F96.0
057A:  BCF    F8D.0
....................     delay_us(500); 
057C:  MOVLW  02
057E:  MOVLB  2
0580:  MOVWF  xFB
0582:  MOVLW  FA
0584:  MOVWF  xFD
0586:  MOVLB  0
0588:  RCALL  0552
058A:  MOVLB  2
058C:  DECFSZ xFB,F
058E:  BRA    0582
....................     output_float(ONE_WIRE_PIN);     // float the bus high 
0590:  BSF    F96.0
....................     delay_us(500);                  // wait-out remaining initialisation window 
0592:  MOVLW  02
0594:  MOVWF  xFB
0596:  MOVLW  FA
0598:  MOVWF  xFD
059A:  MOVLB  0
059C:  RCALL  0552
059E:  MOVLB  2
05A0:  DECFSZ xFB,F
05A2:  BRA    0596
....................     output_float(ONE_WIRE_PIN); 
05A4:  BSF    F96.0
05A6:  MOVLB  0
05A8:  RETURN 0
.................... } 
....................    
....................    
.................... /* 
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */ 
.................... void onewire_write(int8 data) { 
....................     int8 count; 
....................    
....................     for(count = 0; count < 8; ++count) { 
05AA:  MOVLB  2
05AC:  CLRF   xFC
05AE:  MOVF   xFC,W
05B0:  SUBLW  07
05B2:  BNC   05EA
....................         output_low(ONE_WIRE_PIN); 
05B4:  BCF    F96.0
05B6:  BCF    F8D.0
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
05B8:  MOVLW  07
05BA:  MOVWF  00
05BC:  DECFSZ 00,F
05BE:  BRA    05BC
05C0:  BRA    05C2
....................         output_bit(ONE_WIRE_PIN, shift_right(&data, 1, 0)); // set output bit on 1-wire 
05C2:  BCF    FD8.0
05C4:  RRCF   xFB,F
05C6:  BC    05CC
05C8:  BCF    F8D.0
05CA:  BRA    05CE
05CC:  BSF    F8D.0
05CE:  BCF    F96.0
....................         delay_us(60);               // wait until end of write slot. 
05D0:  MOVLW  EF
05D2:  MOVWF  00
05D4:  DECFSZ 00,F
05D6:  BRA    05D4
05D8:  BRA    05DA
....................         output_float(ONE_WIRE_PIN); // set 1-wire high again, 
05DA:  BSF    F96.0
....................         delay_us(2);                // for more than 1us minimum. 
05DC:  MOVLW  07
05DE:  MOVWF  00
05E0:  DECFSZ 00,F
05E2:  BRA    05E0
05E4:  BRA    05E6
05E6:  INCF   xFC,F
05E8:  BRA    05AE
....................     } 
05EA:  MOVLB  0
05EC:  RETURN 0
.................... } 
....................    
.................... /* 
....................  * onewire_read() 
....................  * Description: reads and returns a byte of data from the device. 
....................  */ 
.................... int onewire_read() { 
....................     int count, data; 
....................    
....................     for(count = 0; count < 8; ++count) { 
05EE:  MOVLB  2
05F0:  CLRF   xFB
05F2:  MOVF   xFB,W
05F4:  SUBLW  07
05F6:  BNC   062E
....................         output_low(ONE_WIRE_PIN); 
05F8:  BCF    F96.0
05FA:  BCF    F8D.0
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
05FC:  MOVLW  07
05FE:  MOVWF  00
0600:  DECFSZ 00,F
0602:  BRA    0600
0604:  BRA    0606
....................         output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
0606:  BSF    F96.0
....................         delay_us(8);                // let device state stabilise, 
0608:  MOVLW  1F
060A:  MOVWF  00
060C:  DECFSZ 00,F
060E:  BRA    060C
0610:  BRA    0612
....................         shift_right(&data, 1, input(ONE_WIRE_PIN)); // and load result. 
0612:  BSF    F96.0
0614:  BTFSC  F84.0
0616:  BRA    061C
0618:  BCF    FD8.0
061A:  BRA    061E
061C:  BSF    FD8.0
061E:  RRCF   xFC,F
....................         delay_us(120);              // wait until end of read slot. 
0620:  MOVLW  78
0622:  MOVWF  xFD
0624:  MOVLB  0
0626:  RCALL  0552
0628:  MOVLB  2
062A:  INCF   xFB,F
062C:  BRA    05F2
....................     } 
....................     return data; 
062E:  MOVFF  2FC,01
0632:  MOVLB  0
0634:  RETURN 0
.................... } 
....................    
.................... #endif /*ONE_WIRE_C*/ 
....................  
.................... #include "TV_ds1820.c" 
.................... #ifndef DS1820_C 
.................... #define DS1820_C 
....................    
....................    
.................... float ds1820_read(); 
.................... void ds1820_configure(int8 TH, int8 TL, int8 config); 
....................    
.................... /* 
....................  * ds1820_read() 
....................  * Description: reads the ds18x20 device on the 1-wire bus and returns 
....................  *              the temperature 
....................  */ 
....................     
.................... float ds1820_read() { 
*
07E6:  MOVLB  2
07E8:  CLRF   xF2
....................     int8 busy=0, temp1, temp2; 
....................     signed int16 temp3; 
....................     float result; 
....................        
....................     //ds1820_configure(0x00, 0x00, 0x00);     //9 bit resolution 
....................    
....................     onewire_reset(); 
07EA:  MOVLB  0
07EC:  RCALL  0578
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
07EE:  MOVLW  CC
07F0:  MOVLB  2
07F2:  MOVWF  xFB
07F4:  MOVLB  0
07F6:  RCALL  05AA
....................     onewire_write(0x44);            //Start temperature conversion 
07F8:  MOVLW  44
07FA:  MOVLB  2
07FC:  MOVWF  xFB
07FE:  MOVLB  0
0800:  RCALL  05AA
....................    
....................     while(busy == 0)                //Wait while busy (bus is low) 
0802:  MOVLB  2
0804:  MOVF   xF2,F
0806:  BNZ   0814
....................         busy = onewire_read(); 
0808:  MOVLB  0
080A:  RCALL  05EE
080C:  MOVFF  01,2F2
0810:  BRA    0802
0812:  MOVLB  2
....................    
....................     onewire_reset(); 
0814:  MOVLB  0
0816:  RCALL  0578
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
0818:  MOVLW  CC
081A:  MOVLB  2
081C:  MOVWF  xFB
081E:  MOVLB  0
0820:  RCALL  05AA
....................     onewire_write(0xBE);            //Read scratchpad 
0822:  MOVLW  BE
0824:  MOVLB  2
0826:  MOVWF  xFB
0828:  MOVLB  0
082A:  RCALL  05AA
....................     temp1 = onewire_read(); 
082C:  RCALL  05EE
082E:  MOVFF  01,2F3
....................     temp2 = onewire_read(); 
0832:  RCALL  05EE
0834:  MOVFF  01,2F4
....................     temp3 = make16(temp2, temp1); 
0838:  MOVFF  2F4,2F6
083C:  MOVFF  2F3,2F5
....................     
....................     //result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
....................     result = (float) temp3 / 16.0;    //Calculation for DS18B20 
0840:  MOVFF  2F6,2FC
0844:  MOVFF  2F5,2FB
0848:  BRA    0636
084A:  MOVFF  03,2FE
084E:  MOVFF  02,2FD
0852:  MOVFF  01,2FC
0856:  MOVFF  00,2FB
085A:  MOVFF  03,305
085E:  MOVFF  02,304
0862:  MOVFF  01,303
0866:  MOVFF  00,302
086A:  MOVLB  3
086C:  CLRF   x09
086E:  CLRF   x08
0870:  CLRF   x07
0872:  MOVLW  83
0874:  MOVWF  x06
0876:  MOVLB  0
0878:  RCALL  0688
087A:  MOVFF  03,2FA
087E:  MOVFF  02,2F9
0882:  MOVFF  01,2F8
0886:  MOVFF  00,2F7
....................     
....................     delay_ms(200); 
088A:  MOVLW  C8
088C:  MOVLB  2
088E:  MOVWF  xFE
0890:  MOVLB  0
0892:  RCALL  0384
....................     return(result); 
0894:  MOVFF  2F7,00
0898:  MOVFF  2F8,01
089C:  MOVFF  2F9,02
08A0:  MOVFF  2FA,03
08A4:  GOTO   1ADC (RETURN)
.................... } 
....................    
.................... /* 
....................  * ds1820_configure(int8 TH, int8 LH, int8 config) 
....................  * Description: writes configuration data to the DS18x20 device 
....................  * Arguments: alarm trigger high, alarm trigger low, configuration 
....................  */ 
....................    
.................... void ds1820_configure(int8 TH, int8 TL, int8 config) { 
....................     onewire_reset(); 
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
....................     onewire_write(0x4E);            //Write to scratchpad 
....................     onewire_write(TH); 
....................     onewire_write(TL); 
....................     onewire_write(config); 
.................... } 
....................    
.................... #endif /*DS1820_C*/ 
....................  
....................  
....................  
.................... char querystring[200]; 
.................... float temperature=0,doValue=0,phValue=0,tdsValue=60,turb=0,ecVolt=0,AnalogAverage=0; 
....................  
.................... float  buf[20]; 
.................... float avgValue, tempph; 
.................... float readPh(); 
.................... void batsim808(); 
.................... void erase_buffer_sim(); 
.................... void time(char *expected_answer,unsigned int16 time1); 
.................... float readturb(); 
.................... void readSensor(); 
.................... void readTds(); 
.................... void sendSMS(char *s); 
.................... //int1 sendATcommand(char *command, char *expected_answer,unsigned int16 mstimeout); 
.................... void sendData(); 
.................... float doArray[]={14.60,14.20,13.81,13.45,13.09,12.76,12.44,12.13,11.83,11.55,11.28,11.02,10.77,10.53,10.29,10.07,9.86, 
.................... 9.65,9.45,9.26,9.08,8.90,8.73,8.56,8.40,8.24,8.09,7.95,7.81,7.67,7.54,7.41,7.29,7.17,7.05,6.93,6.82,6.72,6.61,6.51,6.41}; 
.................... int8 buff_index=0; 
.................... const unsigned int8 buffer_size =100; 
.................... char c,buffer[buffer_size]; 
.................... unsigned int16 sendCount=0; 
.................... int8 simCount, biendem=0,phone[12]=""; 
.................... int1 enSim; 
.................... const int8 sendDataTime=1000,numReadings = 20; 
.................... unsigned int16 readings[numReadings],AnalogValueTotal=0; 
.................... unsigned int index=0;  
.................... float wartemp[20]; 
....................  
.................... #INT_TIMER1                                 // Timer1 interrupt ISR 
.................... void timer1_isr() 
.................... { 
....................    set_timer1(5536); //1/(48M/16)x60000 
*
00A2:  MOVLW  15
00A4:  MOVWF  FCF
00A6:  MOVLW  A0
00A8:  MOVWF  FCE
....................     
....................       sendCount++; 
00AA:  MOVLB  2
00AC:  INCF   x63,F
00AE:  BTFSC  FD8.2
00B0:  INCF   x64,F
....................    if (enSim) simCount++; 
00B2:  BTFSS  x73.0
00B4:  BRA    00B8
00B6:  INCF   x65,F
.................... } 
00B8:  BCF    F9E.0
00BA:  MOVLB  0
00BC:  GOTO   0060
.................... #INT_RDA 
.................... void RDA_isr() 
.................... { 
....................    c=fgetc(UARTSIM); 
*
0112:  BTFSS  F9E.5
0114:  BRA    0112
0116:  MOVFF  FAE,1FE
011A:  MOVLB  1
....................    buffer[buff_index]=c; 
011C:  CLRF   03
011E:  MOVF   xFD,W
0120:  ADDLW  FF
0122:  MOVWF  FE9
0124:  MOVLW  01
0126:  ADDWFC 03,W
0128:  MOVWF  FEA
012A:  MOVFF  1FE,FEF
....................    fprintf(UART1,"%c",c); 
012E:  MOVFF  1FE,316
0132:  MOVLB  0
0134:  RCALL  00C0
....................    buff_index++; 
0136:  MOVLB  1
0138:  INCF   xFD,F
013A:  BCF    F9E.5
013C:  MOVLB  0
013E:  GOTO   0060
.................... } 
.................... void main() 
*
2334:  CLRF   FF8
2336:  BCF    FD0.7
2338:  BSF    07.7
233A:  BCF    F95.4
233C:  BSF    F8C.4
233E:  BSF    FB8.3
2340:  MOVLW  E1
2342:  MOVWF  FAF
2344:  MOVLW  04
2346:  MOVWF  FB0
2348:  MOVLW  A6
234A:  MOVWF  FAC
234C:  MOVLW  90
234E:  MOVWF  FAB
2350:  CLRF   xE8
2352:  CLRF   xE7
2354:  CLRF   xE6
2356:  CLRF   xE5
2358:  CLRF   xEC
235A:  CLRF   xEB
235C:  CLRF   xEA
235E:  CLRF   xE9
2360:  CLRF   xF0
2362:  CLRF   xEF
2364:  CLRF   xEE
2366:  CLRF   xED
2368:  CLRF   xF4
236A:  CLRF   xF3
236C:  MOVLW  70
236E:  MOVWF  xF2
2370:  MOVLW  84
2372:  MOVWF  xF1
2374:  CLRF   xF8
2376:  CLRF   xF7
2378:  CLRF   xF6
237A:  CLRF   xF5
237C:  CLRF   xFC
237E:  CLRF   xFB
2380:  CLRF   xFA
2382:  CLRF   xF9
2384:  MOVLB  1
2386:  CLRF   x00
2388:  MOVLB  0
238A:  CLRF   xFF
238C:  CLRF   xFE
238E:  CLRF   xFD
2390:  MOVLB  1
2392:  CLRF   xFD
2394:  MOVLB  2
2396:  CLRF   x64
2398:  CLRF   x63
239A:  CLRF   x66
239C:  CLRF   x9D
239E:  CLRF   x9C
23A0:  CLRF   x9E
23A2:  CLRF   xF0
23A4:  CLRF   xEF
23A6:  MOVF   FC1,W
23A8:  ANDLW  C0
23AA:  IORLW  0F
23AC:  MOVWF  FC1
23AE:  MOVLW  07
23B0:  MOVWF  FB4
23B2:  BRA    2466
23B4:  DATA 02,00
23B6:  DATA 17,00
23B8:  DATA 00,A4
23BA:  DATA 01,59
23BC:  DATA 82,69
23BE:  DATA 99,9A
23C0:  DATA 82,63
23C2:  DATA 33,33
23C4:  DATA 82,5C
23C6:  DATA F5,C3
23C8:  DATA 82,57
23CA:  DATA 33,33
23CC:  DATA 82,51
23CE:  DATA 70,A4
23D0:  DATA 82,4C
23D2:  DATA 28,F6
23D4:  DATA 82,47
23D6:  DATA 0A,3D
23D8:  DATA 82,42
23DA:  DATA 14,7B
23DC:  DATA 82,3D
23DE:  DATA 47,AE
23E0:  DATA 82,38
23E2:  DATA CC,CD
23E4:  DATA 82,34
23E6:  DATA 7A,E1
23E8:  DATA 82,30
23EA:  DATA 51,EC
23EC:  DATA 82,2C
23EE:  DATA 51,EC
23F0:  DATA 82,28
23F2:  DATA 7A,E1
23F4:  DATA 82,24
23F6:  DATA A3,D7
23F8:  DATA 82,21
23FA:  DATA 1E,B8
23FC:  DATA 82,1D
23FE:  DATA C2,8F
2400:  DATA 82,1A
2402:  DATA 66,66
2404:  DATA 82,17
2406:  DATA 33,33
2408:  DATA 82,14
240A:  DATA 28,F6
240C:  DATA 82,11
240E:  DATA 47,AE
2410:  DATA 82,0E
2412:  DATA 66,66
2414:  DATA 82,0B
2416:  DATA AE,14
2418:  DATA 82,08
241A:  DATA F5,C3
241C:  DATA 82,06
241E:  DATA 66,66
2420:  DATA 82,03
2422:  DATA D7,0A
2424:  DATA 82,01
2426:  DATA 70,A4
2428:  DATA 81,7E
242A:  DATA 66,66
242C:  DATA 81,79
242E:  DATA EB,85
2430:  DATA 81,75
2432:  DATA 70,A4
2434:  DATA 81,71
2436:  DATA 47,AE
2438:  DATA 81,6D
243A:  DATA 1E,B8
243C:  DATA 81,69
243E:  DATA 47,AE
2440:  DATA 81,65
2442:  DATA 70,A4
2444:  DATA 81,61
2446:  DATA 99,9A
2448:  DATA 81,5D
244A:  DATA C2,8F
244C:  DATA 81,5A
244E:  DATA 3D,71
2450:  DATA 81,57
2452:  DATA 0A,3D
2454:  DATA 81,53
2456:  DATA 85,1F
2458:  DATA 81,50
245A:  DATA 51,EC
245C:  DATA 81,4D
245E:  DATA 1E,B8
2460:  DATA 01,02
2462:  DATA 67,00
2464:  DATA 00,00
2466:  MOVLW  00
2468:  MOVWF  FF8
246A:  MOVLW  23
246C:  MOVWF  FF7
246E:  MOVLW  B4
2470:  MOVWF  FF6
2472:  TBLRD*+
2474:  MOVF   FF5,W
2476:  MOVWF  00
2478:  XORLW  00
247A:  BZ    24A2
247C:  TBLRD*+
247E:  MOVF   FF5,W
2480:  MOVWF  01
2482:  BTFSC  FE8.7
2484:  BRA    2490
2486:  ANDLW  0F
2488:  MOVWF  FEA
248A:  TBLRD*+
248C:  MOVFF  FF5,FE9
2490:  BTFSC  01.6
2492:  TBLRD*+
2494:  BTFSS  01.6
2496:  TBLRD*+
2498:  MOVFF  FF5,FEE
249C:  DCFSNZ 00,F
249E:  BRA    2472
24A0:  BRA    2494
24A2:  CLRF   FF8
.................... { 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
24A4:  MOVF   FC0,W
24A6:  ANDLW  C0
24A8:  IORLW  07
24AA:  MOVWF  FC0
24AC:  BSF    FC0.7
24AE:  BSF    FC2.0
....................    setup_adc_ports(AN0_TO_AN4); 
24B0:  MOVF   FC1,W
24B2:  ANDLW  C0
24B4:  IORLW  0A
24B6:  MOVWF  FC1
....................    setup_timer_1(T1_INTERNAL | T1_DIV_BY_4); 
24B8:  MOVLW  A5
24BA:  MOVWF  FCD
....................    enable_interrupts(INT_RDA); 
24BC:  BSF    F9D.5
....................    set_timer1(5536); 
24BE:  MOVLW  15
24C0:  MOVWF  FCF
24C2:  MOVLW  A0
24C4:  MOVWF  FCE
....................    enable_interrupts(INT_TIMER1);  
24C6:  BSF    F9D.0
....................    enable_interrupts(GLOBAL); 
24C8:  MOVLW  C0
24CA:  IORWF  FF2,F
....................    batsim808(); 
24CC:  MOVLB  0
24CE:  GOTO   0426
....................    fprintf(UART1,"Setup Successful\n"); 
24D2:  MOVLW  42
24D4:  MOVWF  FF6
24D6:  MOVLW  01
24D8:  MOVWF  FF7
24DA:  CALL   03AE
....................     
....................    //delay_ms(1000); 
....................    while(TRUE) 
....................    { 
....................          
....................        readSensor(); 
24DE:  GOTO   1AD8
....................         
....................        fprintf(UART1,"TEMP: %2.2f\r\n",temperature); 
24E2:  MOVLW  54
24E4:  MOVWF  FF6
24E6:  MOVLW  01
24E8:  MOVWF  FF7
24EA:  MOVLW  06
24EC:  MOVLB  2
24EE:  MOVWF  xF1
24F0:  MOVLB  0
24F2:  CALL   1B5A
24F6:  MOVLW  89
24F8:  MOVWF  FE9
24FA:  MOVFF  E8,2F4
24FE:  MOVFF  E7,2F3
2502:  MOVFF  E6,2F2
2506:  MOVFF  E5,2F1
250A:  MOVLW  02
250C:  MOVLB  2
250E:  MOVWF  xF5
2510:  MOVLB  0
2512:  CALL   1C70
2516:  CLRF   16
2518:  BTFSC  FF2.7
251A:  BSF    16.7
251C:  BCF    FF2.7
251E:  MOVLW  0D
2520:  MOVLB  3
2522:  MOVWF  x16
2524:  MOVLB  0
2526:  CALL   00C0
252A:  BTFSC  16.7
252C:  BSF    FF2.7
252E:  CLRF   16
2530:  BTFSC  FF2.7
2532:  BSF    16.7
2534:  BCF    FF2.7
2536:  MOVLW  0A
2538:  MOVLB  3
253A:  MOVWF  x16
253C:  MOVLB  0
253E:  CALL   00C0
2542:  BTFSC  16.7
2544:  BSF    FF2.7
....................         
....................        fprintf(UART1,"DO: %2.1f\r\n",doValue); 
2546:  MOVLW  62
2548:  MOVWF  FF6
254A:  MOVLW  01
254C:  MOVWF  FF7
254E:  MOVLW  04
2550:  MOVLB  2
2552:  MOVWF  xF1
2554:  MOVLB  0
2556:  CALL   1B5A
255A:  MOVLW  01
255C:  MOVWF  FE9
255E:  MOVFF  EC,2F4
2562:  MOVFF  EB,2F3
2566:  MOVFF  EA,2F2
256A:  MOVFF  E9,2F1
256E:  MOVLB  2
2570:  MOVWF  xF5
2572:  MOVLB  0
2574:  CALL   1C70
2578:  CLRF   16
257A:  BTFSC  FF2.7
257C:  BSF    16.7
257E:  BCF    FF2.7
2580:  MOVLW  0D
2582:  MOVLB  3
2584:  MOVWF  x16
2586:  MOVLB  0
2588:  CALL   00C0
258C:  BTFSC  16.7
258E:  BSF    FF2.7
2590:  CLRF   16
2592:  BTFSC  FF2.7
2594:  BSF    16.7
2596:  BCF    FF2.7
2598:  MOVLW  0A
259A:  MOVLB  3
259C:  MOVWF  x16
259E:  MOVLB  0
25A0:  CALL   00C0
25A4:  BTFSC  16.7
25A6:  BSF    FF2.7
....................         
....................        fprintf(UART1,"pH: %2.1f\r\n",phValue); 
25A8:  MOVLW  6E
25AA:  MOVWF  FF6
25AC:  MOVLW  01
25AE:  MOVWF  FF7
25B0:  MOVLW  04
25B2:  MOVLB  2
25B4:  MOVWF  xF1
25B6:  MOVLB  0
25B8:  CALL   1B5A
25BC:  MOVLW  01
25BE:  MOVWF  FE9
25C0:  MOVFF  F0,2F4
25C4:  MOVFF  EF,2F3
25C8:  MOVFF  EE,2F2
25CC:  MOVFF  ED,2F1
25D0:  MOVLB  2
25D2:  MOVWF  xF5
25D4:  MOVLB  0
25D6:  CALL   1C70
25DA:  CLRF   16
25DC:  BTFSC  FF2.7
25DE:  BSF    16.7
25E0:  BCF    FF2.7
25E2:  MOVLW  0D
25E4:  MOVLB  3
25E6:  MOVWF  x16
25E8:  MOVLB  0
25EA:  CALL   00C0
25EE:  BTFSC  16.7
25F0:  BSF    FF2.7
25F2:  CLRF   16
25F4:  BTFSC  FF2.7
25F6:  BSF    16.7
25F8:  BCF    FF2.7
25FA:  MOVLW  0A
25FC:  MOVLB  3
25FE:  MOVWF  x16
2600:  MOVLB  0
2602:  CALL   00C0
2606:  BTFSC  16.7
2608:  BSF    FF2.7
....................         
....................        fprintf(UART1,"TURB (percent): %f\r\n", turb); 
260A:  MOVLW  7A
260C:  MOVWF  FF6
260E:  MOVLW  01
2610:  MOVWF  FF7
2612:  MOVLW  10
2614:  MOVLB  2
2616:  MOVWF  xF1
2618:  MOVLB  0
261A:  CALL   1B5A
261E:  MOVLW  89
2620:  MOVWF  FE9
2622:  MOVFF  F8,2F4
2626:  MOVFF  F7,2F3
262A:  MOVFF  F6,2F2
262E:  MOVFF  F5,2F1
2632:  MOVLW  02
2634:  MOVLB  2
2636:  MOVWF  xF5
2638:  MOVLB  0
263A:  CALL   1C70
263E:  CLRF   16
2640:  BTFSC  FF2.7
2642:  BSF    16.7
2644:  BCF    FF2.7
2646:  MOVLW  0D
2648:  MOVLB  3
264A:  MOVWF  x16
264C:  MOVLB  0
264E:  CALL   00C0
2652:  BTFSC  16.7
2654:  BSF    FF2.7
2656:  CLRF   16
2658:  BTFSC  FF2.7
265A:  BSF    16.7
265C:  BCF    FF2.7
265E:  MOVLW  0A
2660:  MOVLB  3
2662:  MOVWF  x16
2664:  MOVLB  0
2666:  CALL   00C0
266A:  BTFSC  16.7
266C:  BSF    FF2.7
....................         
....................        fprintf(UART1,"TDS: %3.2f\r\n",tdsValue); 
266E:  MOVLW  90
2670:  MOVWF  FF6
2672:  MOVLW  01
2674:  MOVWF  FF7
2676:  MOVLW  05
2678:  MOVLB  2
267A:  MOVWF  xF1
267C:  MOVLB  0
267E:  CALL   1B5A
2682:  MOVLW  02
2684:  MOVWF  FE9
2686:  MOVFF  F4,2F4
268A:  MOVFF  F3,2F3
268E:  MOVFF  F2,2F2
2692:  MOVFF  F1,2F1
2696:  MOVLB  2
2698:  MOVWF  xF5
269A:  MOVLB  0
269C:  CALL   1C70
26A0:  CLRF   16
26A2:  BTFSC  FF2.7
26A4:  BSF    16.7
26A6:  BCF    FF2.7
26A8:  MOVLW  0D
26AA:  MOVLB  3
26AC:  MOVWF  x16
26AE:  MOVLB  0
26B0:  CALL   00C0
26B4:  BTFSC  16.7
26B6:  BSF    FF2.7
26B8:  CLRF   16
26BA:  BTFSC  FF2.7
26BC:  BSF    16.7
26BE:  BCF    FF2.7
26C0:  MOVLW  0A
26C2:  MOVLB  3
26C4:  MOVWF  x16
26C6:  MOVLB  0
26C8:  CALL   00C0
26CC:  BTFSC  16.7
26CE:  BSF    FF2.7
....................        delay_ms(2000); 
26D0:  MOVLW  08
26D2:  MOVLB  2
26D4:  MOVWF  xF1
26D6:  MOVLW  FA
26D8:  MOVWF  xFE
26DA:  MOVLB  0
26DC:  CALL   0384
26E0:  MOVLB  2
26E2:  DECFSZ xF1,F
26E4:  BRA    26D6
....................        if (sendCount>=sendDataTime)  
26E6:  MOVF   x64,F
26E8:  BNZ   26F0
26EA:  MOVF   x63,W
26EC:  SUBLW  E7
26EE:  BC    26F8
....................        { 
....................          sendCount=0;                  
26F0:  CLRF   x64
26F2:  CLRF   x63
....................          sendData(); 
26F4:  MOVLB  0
26F6:  BRA    20AA
....................           
....................        } 
26F8:  MOVLB  0
26FA:  BRA    24DE
....................          
....................        //delay_ms(2000); 
....................    } 
.................... } 
.................... void readSensor(void) 
26FC:  SLEEP 
.................... { 
....................    temperature = ds1820_read();  
*
1AD8:  GOTO   07E6
1ADC:  MOVFF  03,E8
1AE0:  MOVFF  02,E7
1AE4:  MOVFF  01,E6
1AE8:  MOVFF  00,E5
....................    int doConvert= (int)temperature; 
1AEC:  MOVFF  E8,2F9
1AF0:  MOVFF  E7,2F8
1AF4:  MOVFF  E6,2F7
1AF8:  MOVFF  E5,2F6
1AFC:  CALL   08A8
1B00:  MOVFF  01,2F1
....................        doValue = doArray[doConvert]; 
1B04:  MOVLB  2
1B06:  MOVF   xF1,W
1B08:  MULLW  04
1B0A:  MOVF   FF3,W
1B0C:  CLRF   03
1B0E:  ADDLW  59
1B10:  MOVWF  FE9
1B12:  MOVLW  01
1B14:  ADDWFC 03,W
1B16:  MOVWF  FEA
1B18:  MOVFF  FEF,E9
1B1C:  MOVFF  FEC,EA
1B20:  MOVFF  FEC,EB
1B24:  MOVFF  FEC,EC
....................    phValue=readPh(); 
1B28:  MOVLB  0
1B2A:  GOTO   0D30
1B2E:  MOVFF  03,F0
1B32:  MOVFF  02,EF
1B36:  MOVFF  01,EE
1B3A:  MOVFF  00,ED
....................    turb= readTurb(); 
1B3E:  GOTO   105A
1B42:  MOVFF  03,F8
1B46:  MOVFF  02,F7
1B4A:  MOVFF  01,F6
1B4E:  MOVFF  00,F5
....................    readTds(); 
1B52:  GOTO   10FC
1B56:  GOTO   24E2 (RETURN)
.................... } 
.................... float readPh() 
....................    { 
....................       set_adc_channel(3); 
*
0D30:  MOVLW  0C
0D32:  MOVWF  01
0D34:  MOVF   FC2,W
0D36:  ANDLW  C3
0D38:  IORWF  01,W
0D3A:  MOVWF  FC2
....................       delay_us(20); 
0D3C:  MOVLW  4F
0D3E:  MOVWF  00
0D40:  DECFSZ 00,F
0D42:  BRA    0D40
0D44:  BRA    0D46
....................       for (int s = 0; s < 10; s++) 
0D46:  MOVLB  2
0D48:  CLRF   xF2
0D4A:  MOVF   xF2,W
0D4C:  SUBLW  09
0D4E:  BNC   0D96
....................       { 
....................          buf[s] = read_adc(); 
0D50:  MOVF   xF2,W
0D52:  MULLW  04
0D54:  MOVF   FF3,W
0D56:  CLRF   03
0D58:  ADDLW  01
0D5A:  MOVWF  FE9
0D5C:  MOVLW  01
0D5E:  ADDWFC 03,W
0D60:  MOVWF  FEA
0D62:  BSF    FC2.1
0D64:  BTFSC  FC2.1
0D66:  BRA    0D64
0D68:  MOVFF  FC4,301
0D6C:  MOVFF  FC3,300
0D70:  MOVLB  0
0D72:  RCALL  08E4
0D74:  MOVFF  00,FEF
0D78:  MOVFF  01,FEC
0D7C:  MOVFF  02,FEC
0D80:  MOVFF  03,FEC
....................          delay_ms(10); 
0D84:  MOVLW  0A
0D86:  MOVLB  2
0D88:  MOVWF  xFE
0D8A:  MOVLB  0
0D8C:  CALL   0384
0D90:  MOVLB  2
0D92:  INCF   xF2,F
0D94:  BRA    0D4A
....................       } 
....................       for (int i = 0; i < 9; i++) 
0D96:  CLRF   xF3
0D98:  MOVF   xF3,W
0D9A:  SUBLW  08
0D9C:  BTFSS  FD8.0
0D9E:  BRA    0EBC
....................       { 
....................          for (int j = i + 1; j < 10; j++) 
0DA0:  MOVLW  01
0DA2:  ADDWF  xF3,W
0DA4:  MOVWF  xF4
0DA6:  MOVF   xF4,W
0DA8:  SUBLW  09
0DAA:  BTFSS  FD8.0
0DAC:  BRA    0EB8
....................          { 
....................             if (buf[i] > buf[j]) 
0DAE:  MOVF   xF3,W
0DB0:  MULLW  04
0DB2:  MOVF   FF3,W
0DB4:  CLRF   03
0DB6:  ADDLW  01
0DB8:  MOVWF  FE9
0DBA:  MOVLW  01
0DBC:  ADDWFC 03,W
0DBE:  MOVWF  FEA
0DC0:  MOVFF  FEF,2FE
0DC4:  MOVFF  FEC,2FF
0DC8:  MOVFF  FEC,300
0DCC:  MOVFF  FEC,301
0DD0:  MOVF   xF4,W
0DD2:  MULLW  04
0DD4:  MOVF   FF3,W
0DD6:  CLRF   03
0DD8:  ADDLW  01
0DDA:  MOVWF  FE9
0DDC:  MOVLW  01
0DDE:  ADDWFC 03,W
0DE0:  MOVWF  FEA
0DE2:  MOVFF  FEF,00
0DE6:  MOVFF  FEC,01
0DEA:  MOVFF  FEC,02
0DEE:  MOVFF  FEC,03
0DF2:  MOVFF  03,305
0DF6:  MOVFF  02,304
0DFA:  MOVFF  01,303
0DFE:  MOVFF  00,302
0E02:  MOVFF  301,309
0E06:  MOVFF  300,308
0E0A:  MOVFF  2FF,307
0E0E:  MOVFF  2FE,306
0E12:  MOVLB  0
0E14:  BRA    091A
0E16:  BNC   0EB2
....................             { 
....................                tempph = buf[i]; 
0E18:  MOVLB  2
0E1A:  MOVF   xF3,W
0E1C:  MULLW  04
0E1E:  MOVF   FF3,W
0E20:  CLRF   03
0E22:  ADDLW  01
0E24:  MOVWF  FE9
0E26:  MOVLW  01
0E28:  ADDWFC 03,W
0E2A:  MOVWF  FEA
0E2C:  MOVFF  FEF,155
0E30:  MOVFF  FEC,156
0E34:  MOVFF  FEC,157
0E38:  MOVFF  FEC,158
....................                buf[i] = buf[j]; 
0E3C:  MOVF   xF3,W
0E3E:  MULLW  04
0E40:  MOVF   FF3,W
0E42:  CLRF   03
0E44:  ADDLW  01
0E46:  MOVWF  01
0E48:  MOVLW  01
0E4A:  ADDWFC 03,F
0E4C:  MOVFF  01,2FE
0E50:  MOVFF  03,2FF
0E54:  MOVF   xF4,W
0E56:  MULLW  04
0E58:  MOVF   FF3,W
0E5A:  CLRF   03
0E5C:  ADDLW  01
0E5E:  MOVWF  FE9
0E60:  MOVLW  01
0E62:  ADDWFC 03,W
0E64:  MOVWF  FEA
0E66:  MOVFF  FEF,00
0E6A:  MOVFF  FEC,01
0E6E:  MOVFF  FEC,02
0E72:  MOVFF  FEC,03
0E76:  MOVFF  2FF,FEA
0E7A:  MOVFF  2FE,FE9
0E7E:  MOVFF  00,FEF
0E82:  MOVFF  01,FEC
0E86:  MOVFF  02,FEC
0E8A:  MOVFF  03,FEC
....................                buf[j] = tempph; 
0E8E:  MOVF   xF4,W
0E90:  MULLW  04
0E92:  MOVF   FF3,W
0E94:  CLRF   03
0E96:  ADDLW  01
0E98:  MOVWF  FE9
0E9A:  MOVLW  01
0E9C:  ADDWFC 03,W
0E9E:  MOVWF  FEA
0EA0:  MOVFF  155,FEF
0EA4:  MOVFF  156,FEC
0EA8:  MOVFF  157,FEC
0EAC:  MOVFF  158,FEC
0EB0:  MOVLB  0
....................             } 
0EB2:  MOVLB  2
0EB4:  INCF   xF4,F
0EB6:  BRA    0DA6
....................          } 
0EB8:  INCF   xF3,F
0EBA:  BRA    0D98
....................       } 
....................   avgValue = 0; 
0EBC:  MOVLB  1
0EBE:  CLRF   x54
0EC0:  CLRF   x53
0EC2:  CLRF   x52
0EC4:  CLRF   x51
....................   for (int a = 2; a < 8; a++) 
0EC6:  MOVLW  02
0EC8:  MOVLB  2
0ECA:  MOVWF  xF5
0ECC:  MOVF   xF5,W
0ECE:  SUBLW  07
0ED0:  BNC   0F40
....................       avgValue += buf[i]; 
0ED2:  MOVF   xF3,W
0ED4:  MULLW  04
0ED6:  MOVF   FF3,W
0ED8:  CLRF   03
0EDA:  ADDLW  01
0EDC:  MOVWF  FE9
0EDE:  MOVLW  01
0EE0:  ADDWFC 03,W
0EE2:  MOVWF  FEA
0EE4:  MOVFF  FEF,00
0EE8:  MOVFF  FEC,01
0EEC:  MOVFF  FEC,02
0EF0:  MOVFF  FEC,03
0EF4:  MOVFF  FEA,2FF
0EF8:  MOVFF  FE9,2FE
0EFC:  BCF    FD8.1
0EFE:  MOVFF  154,305
0F02:  MOVFF  153,304
0F06:  MOVFF  152,303
0F0A:  MOVFF  151,302
0F0E:  MOVFF  03,309
0F12:  MOVFF  02,308
0F16:  MOVFF  01,307
0F1A:  MOVFF  00,306
0F1E:  MOVLB  0
0F20:  RCALL  0996
0F22:  MOVFF  2FF,FEA
0F26:  MOVFF  2FE,FE9
0F2A:  MOVFF  03,154
0F2E:  MOVFF  02,153
0F32:  MOVFF  01,152
0F36:  MOVFF  00,151
0F3A:  MOVLB  2
0F3C:  INCF   xF5,F
0F3E:  BRA    0ECC
....................       float pHVol = (float)avgValue * 5.0 / 1024 / 6; 
....................       float phValue1 = -5.70 * pHVol + 21.34; 
0F40:  MOVFF  154,301
0F44:  MOVFF  153,300
0F48:  MOVFF  152,2FF
0F4C:  MOVFF  151,2FE
0F50:  MOVLB  3
0F52:  CLRF   x05
0F54:  CLRF   x04
0F56:  MOVLW  20
0F58:  MOVWF  x03
0F5A:  MOVLW  81
0F5C:  MOVWF  x02
0F5E:  MOVLB  0
0F60:  RCALL  0C0E
0F62:  MOVFF  03,301
0F66:  MOVFF  02,300
0F6A:  MOVFF  01,2FF
0F6E:  MOVFF  00,2FE
0F72:  MOVFF  03,305
0F76:  MOVFF  02,304
0F7A:  MOVFF  01,303
0F7E:  MOVFF  00,302
0F82:  MOVLB  3
0F84:  CLRF   x09
0F86:  CLRF   x08
0F88:  CLRF   x07
0F8A:  MOVLW  89
0F8C:  MOVWF  x06
0F8E:  MOVLB  0
0F90:  CALL   0688
0F94:  MOVFF  03,301
0F98:  MOVFF  02,300
0F9C:  MOVFF  01,2FF
0FA0:  MOVFF  00,2FE
0FA4:  MOVFF  03,305
0FA8:  MOVFF  02,304
0FAC:  MOVFF  01,303
0FB0:  MOVFF  00,302
0FB4:  MOVLB  3
0FB6:  CLRF   x09
0FB8:  CLRF   x08
0FBA:  MOVLW  40
0FBC:  MOVWF  x07
0FBE:  MOVLW  81
0FC0:  MOVWF  x06
0FC2:  MOVLB  0
0FC4:  CALL   0688
0FC8:  MOVFF  03,2F9
0FCC:  MOVFF  02,2F8
0FD0:  MOVFF  01,2F7
0FD4:  MOVFF  00,2F6
0FD8:  MOVLW  66
0FDA:  MOVLB  3
0FDC:  MOVWF  x01
0FDE:  MOVWF  x00
0FE0:  MOVLW  B6
0FE2:  MOVLB  2
0FE4:  MOVWF  xFF
0FE6:  MOVLW  81
0FE8:  MOVWF  xFE
0FEA:  MOVFF  2F9,305
0FEE:  MOVFF  2F8,304
0FF2:  MOVFF  2F7,303
0FF6:  MOVFF  2F6,302
0FFA:  MOVLB  0
0FFC:  RCALL  0C0E
0FFE:  MOVFF  03,301
1002:  MOVFF  02,300
1006:  MOVFF  01,2FF
100A:  MOVFF  00,2FE
100E:  BCF    FD8.1
1010:  MOVFF  03,305
1014:  MOVFF  02,304
1018:  MOVFF  01,303
101C:  MOVFF  00,302
1020:  MOVLW  52
1022:  MOVLB  3
1024:  MOVWF  x09
1026:  MOVLW  B8
1028:  MOVWF  x08
102A:  MOVLW  2A
102C:  MOVWF  x07
102E:  MOVLW  83
1030:  MOVWF  x06
1032:  MOVLB  0
1034:  RCALL  0996
1036:  MOVFF  03,2FD
103A:  MOVFF  02,2FC
103E:  MOVFF  01,2FB
1042:  MOVFF  00,2FA
....................       return phValue1; 
1046:  MOVFF  2FA,00
104A:  MOVFF  2FB,01
104E:  MOVFF  2FC,02
1052:  MOVFF  2FD,03
1056:  GOTO   1B2E (RETURN)
.................... } 
.................... float readTurb() 
105A:  MOVLB  2
105C:  CLRF   xF3
105E:  CLRF   xF2
.................... { 
....................    int16 turbVolt=0; 
....................    set_adc_channel(1); 
1060:  MOVLW  04
1062:  MOVWF  01
1064:  MOVF   FC2,W
1066:  ANDLW  C3
1068:  IORWF  01,W
106A:  MOVWF  FC2
....................    delay_us(20); 
106C:  MOVLW  4F
106E:  MOVWF  00
1070:  DECFSZ 00,F
1072:  BRA    1070
1074:  BRA    1076
....................    turbVolt=read_adc(); 
1076:  BSF    FC2.1
1078:  BTFSC  FC2.1
107A:  BRA    1078
107C:  MOVFF  FC3,2F2
1080:  MOVFF  FC4,2F3
....................    return (float) turbVolt/1023*100; 
1084:  MOVFF  2F3,301
1088:  MOVFF  2F2,300
108C:  MOVLB  0
108E:  RCALL  08E4
1090:  MOVFF  03,2F7
1094:  MOVFF  02,2F6
1098:  MOVFF  01,2F5
109C:  MOVFF  00,2F4
10A0:  MOVFF  03,305
10A4:  MOVFF  02,304
10A8:  MOVFF  01,303
10AC:  MOVFF  00,302
10B0:  MOVLB  3
10B2:  CLRF   x09
10B4:  MOVLW  C0
10B6:  MOVWF  x08
10B8:  MOVLW  7F
10BA:  MOVWF  x07
10BC:  MOVLW  88
10BE:  MOVWF  x06
10C0:  MOVLB  0
10C2:  CALL   0688
10C6:  MOVFF  03,2F7
10CA:  MOVFF  02,2F6
10CE:  MOVFF  01,2F5
10D2:  MOVFF  00,2F4
10D6:  MOVFF  03,301
10DA:  MOVFF  02,300
10DE:  MOVFF  01,2FF
10E2:  MOVFF  00,2FE
10E6:  MOVLB  3
10E8:  CLRF   x05
10EA:  CLRF   x04
10EC:  MOVLW  48
10EE:  MOVWF  x03
10F0:  MOVLW  85
10F2:  MOVWF  x02
10F4:  MOVLB  0
10F6:  RCALL  0C0E
10F8:  GOTO   1B42 (RETURN)
.................... } 
.................... void readTds() 
10FC:  MOVLB  2
10FE:  CLRF   xF3
1100:  CLRF   xF2
.................... { 
....................       int16 sampleTDS=0; 
....................    
....................       set_adc_channel(0); 
1102:  MOVLW  00
1104:  MOVWF  01
1106:  MOVF   FC2,W
1108:  ANDLW  C3
110A:  IORWF  01,W
110C:  MOVWF  FC2
....................       delay_us(20); 
110E:  MOVLW  4F
1110:  MOVWF  00
1112:  DECFSZ 00,F
1114:  BRA    1112
1116:  BRA    1118
....................       int16 temp = read_adc();    
1118:  BSF    FC2.1
111A:  BTFSC  FC2.1
111C:  BRA    111A
111E:  MOVFF  FC3,2F4
1122:  MOVFF  FC4,2F5
....................       //if (temp<1025) 
....................       ecVolt = (float) temp/1023*5; 
1126:  MOVFF  2F5,301
112A:  MOVFF  2F4,300
112E:  MOVLB  0
1130:  CALL   08E4
1134:  MOVFF  03,2F9
1138:  MOVFF  02,2F8
113C:  MOVFF  01,2F7
1140:  MOVFF  00,2F6
1144:  MOVFF  03,305
1148:  MOVFF  02,304
114C:  MOVFF  01,303
1150:  MOVFF  00,302
1154:  MOVLB  3
1156:  CLRF   x09
1158:  MOVLW  C0
115A:  MOVWF  x08
115C:  MOVLW  7F
115E:  MOVWF  x07
1160:  MOVLW  88
1162:  MOVWF  x06
1164:  MOVLB  0
1166:  CALL   0688
116A:  MOVFF  03,2F9
116E:  MOVFF  02,2F8
1172:  MOVFF  01,2F7
1176:  MOVFF  00,2F6
117A:  MOVFF  03,301
117E:  MOVFF  02,300
1182:  MOVFF  01,2FF
1186:  MOVFF  00,2FE
118A:  MOVLB  3
118C:  CLRF   x05
118E:  CLRF   x04
1190:  MOVLW  20
1192:  MOVWF  x03
1194:  MOVLW  81
1196:  MOVWF  x02
1198:  MOVLB  0
119A:  RCALL  0C0E
119C:  MOVFF  03,FC
11A0:  MOVFF  02,FB
11A4:  MOVFF  01,FA
11A8:  MOVFF  00,F9
....................       //fprintf(UART1,"ok %li\r\n",k);       
....................       AnalogValueTotal = AnalogValueTotal - readings[index]; 
11AC:  BCF    FD8.0
11AE:  MOVLB  2
11B0:  RLCF   x9E,W
11B2:  CLRF   03
11B4:  ADDLW  74
11B6:  MOVWF  FE9
11B8:  MOVLW  02
11BA:  ADDWFC 03,W
11BC:  MOVWF  FEA
11BE:  MOVFF  FEC,03
11C2:  MOVF   FED,F
11C4:  MOVF   FEF,W
11C6:  SUBWF  x9C,F
11C8:  MOVF   03,W
11CA:  SUBWFB x9D,F
....................       readings[index] = temp; 
11CC:  BCF    FD8.0
11CE:  RLCF   x9E,W
11D0:  CLRF   03
11D2:  ADDLW  74
11D4:  MOVWF  FE9
11D6:  MOVLW  02
11D8:  ADDWFC 03,W
11DA:  MOVWF  FEA
11DC:  MOVFF  2F5,FEC
11E0:  MOVF   FED,F
11E2:  MOVFF  2F4,FEF
....................       AnalogValueTotal = AnalogValueTotal + readings[index]; 
11E6:  BCF    FD8.0
11E8:  RLCF   x9E,W
11EA:  CLRF   03
11EC:  ADDLW  74
11EE:  MOVWF  FE9
11F0:  MOVLW  02
11F2:  ADDWFC 03,W
11F4:  MOVWF  FEA
11F6:  MOVFF  FEC,03
11FA:  MOVF   FED,F
11FC:  MOVF   FEF,W
11FE:  ADDWF  x9C,F
1200:  MOVF   03,W
1202:  ADDWFC x9D,F
....................       index++; 
1204:  INCF   x9E,F
....................       //fprintf(UART1,"AnalogAverage: %f, index: %d\r\n",AnalogAverage,index); 
....................       if (index >= numReadings) index = 0; 
1206:  MOVF   x9E,W
1208:  SUBLW  13
120A:  BC    120E
120C:  CLRF   x9E
....................       AnalogAverage = ((float) (AnalogValueTotal) / (1023*numReadings))*5; 
120E:  MOVFF  29D,301
1212:  MOVFF  29C,300
1216:  MOVLB  0
1218:  CALL   08E4
121C:  MOVFF  03,2F9
1220:  MOVFF  02,2F8
1224:  MOVFF  01,2F7
1228:  MOVFF  00,2F6
122C:  MOVFF  03,305
1230:  MOVFF  02,304
1234:  MOVFF  01,303
1238:  MOVFF  00,302
123C:  MOVLB  3
123E:  CLRF   x09
1240:  MOVLW  D8
1242:  MOVWF  x08
1244:  MOVLW  1F
1246:  MOVWF  x07
1248:  MOVLW  8D
124A:  MOVWF  x06
124C:  MOVLB  0
124E:  CALL   0688
1252:  MOVFF  03,2F9
1256:  MOVFF  02,2F8
125A:  MOVFF  01,2F7
125E:  MOVFF  00,2F6
1262:  MOVFF  03,301
1266:  MOVFF  02,300
126A:  MOVFF  01,2FF
126E:  MOVFF  00,2FE
1272:  MOVLB  3
1274:  CLRF   x05
1276:  CLRF   x04
1278:  MOVLW  20
127A:  MOVWF  x03
127C:  MOVLW  81
127E:  MOVWF  x02
1280:  MOVLB  0
1282:  RCALL  0C0E
1284:  MOVFF  03,100
1288:  MOVFF  02,FF
128C:  MOVFF  01,FE
1290:  MOVFF  00,FD
....................       sampleTDS=(AnalogAverage*1000)/(1+0.0185*(temperature-25.0)); //mV/C 
1294:  MOVFF  100,301
1298:  MOVFF  FF,300
129C:  MOVFF  FE,2FF
12A0:  MOVFF  FD,2FE
12A4:  MOVLB  3
12A6:  CLRF   x05
12A8:  CLRF   x04
12AA:  MOVLW  7A
12AC:  MOVWF  x03
12AE:  MOVLW  88
12B0:  MOVWF  x02
12B2:  MOVLB  0
12B4:  RCALL  0C0E
12B6:  MOVFF  03,2F9
12BA:  MOVFF  02,2F8
12BE:  MOVFF  01,2F7
12C2:  MOVFF  00,2F6
12C6:  BSF    FD8.1
12C8:  MOVFF  E8,305
12CC:  MOVFF  E7,304
12D0:  MOVFF  E6,303
12D4:  MOVFF  E5,302
12D8:  MOVLB  3
12DA:  CLRF   x09
12DC:  CLRF   x08
12DE:  MOVLW  48
12E0:  MOVWF  x07
12E2:  MOVLW  83
12E4:  MOVWF  x06
12E6:  MOVLB  0
12E8:  CALL   0996
12EC:  MOVLW  50
12EE:  MOVLB  3
12F0:  MOVWF  x01
12F2:  MOVLW  8D
12F4:  MOVWF  x00
12F6:  MOVLW  17
12F8:  MOVLB  2
12FA:  MOVWF  xFF
12FC:  MOVLW  79
12FE:  MOVWF  xFE
1300:  MOVFF  03,305
1304:  MOVFF  02,304
1308:  MOVFF  01,303
130C:  MOVFF  00,302
1310:  MOVLB  0
1312:  RCALL  0C0E
1314:  BCF    FD8.1
1316:  MOVLB  3
1318:  CLRF   x05
131A:  CLRF   x04
131C:  CLRF   x03
131E:  MOVLW  7F
1320:  MOVWF  x02
1322:  MOVFF  03,309
1326:  MOVFF  02,308
132A:  MOVFF  01,307
132E:  MOVFF  00,306
1332:  MOVLB  0
1334:  CALL   0996
1338:  MOVFF  2F9,305
133C:  MOVFF  2F8,304
1340:  MOVFF  2F7,303
1344:  MOVFF  2F6,302
1348:  MOVFF  03,309
134C:  MOVFF  02,308
1350:  MOVFF  01,307
1354:  MOVFF  00,306
1358:  CALL   0688
135C:  MOVFF  03,2F9
1360:  MOVFF  02,2F8
1364:  MOVFF  01,2F7
1368:  MOVFF  00,2F6
136C:  CALL   08A8
1370:  MOVFF  02,2F3
1374:  MOVFF  01,2F2
....................       if (sampleTDS<315) 
1378:  MOVLB  2
137A:  MOVF   xF3,W
137C:  SUBLW  01
137E:  BTFSS  FD8.0
1380:  BRA    19E8
1382:  BNZ   138C
1384:  MOVF   xF2,W
1386:  SUBLW  3A
1388:  BTFSS  FD8.0
138A:  BRA    19E8
....................       { 
....................       if (sampleTDS<70) tdsValue=0; 
138C:  MOVF   xF3,F
138E:  BNZ   13A4
1390:  MOVF   xF2,W
1392:  SUBLW  45
1394:  BNC   13A4
1396:  MOVLB  0
1398:  CLRF   xF4
139A:  CLRF   xF3
139C:  CLRF   xF2
139E:  CLRF   xF1
13A0:  BRA    19E4
13A2:  MOVLB  2
....................       else if (sampleTDS>3300) tdsValue=1995;  
13A4:  MOVF   xF3,W
13A6:  SUBLW  0B
13A8:  BC    13C8
13AA:  XORLW  FF
13AC:  BNZ   13B4
13AE:  MOVF   xF2,W
13B0:  SUBLW  E4
13B2:  BC    13C8
13B4:  MOVLB  0
13B6:  CLRF   xF4
13B8:  MOVLW  60
13BA:  MOVWF  xF3
13BC:  MOVLW  79
13BE:  MOVWF  xF2
13C0:  MOVLW  89
13C2:  MOVWF  xF1
13C4:  BRA    19E4
13C6:  MOVLB  2
....................          else if (sampleTDS<150) tdsValue=2.375*sampleTDS; 
13C8:  MOVF   xF3,F
13CA:  BNZ   1418
13CC:  MOVF   xF2,W
13CE:  SUBLW  95
13D0:  BNC   1418
13D2:  MOVFF  2F3,301
13D6:  MOVFF  2F2,300
13DA:  MOVLB  0
13DC:  CALL   08E4
13E0:  MOVLB  3
13E2:  CLRF   x01
13E4:  CLRF   x00
13E6:  MOVLW  18
13E8:  MOVLB  2
13EA:  MOVWF  xFF
13EC:  MOVLW  80
13EE:  MOVWF  xFE
13F0:  MOVFF  03,305
13F4:  MOVFF  02,304
13F8:  MOVFF  01,303
13FC:  MOVFF  00,302
1400:  MOVLB  0
1402:  RCALL  0C0E
1404:  MOVFF  03,F4
1408:  MOVFF  02,F3
140C:  MOVFF  01,F2
1410:  MOVFF  00,F1
1414:  BRA    19E4
1416:  MOVLB  2
....................             else if (sampleTDS<180) tdsValue=2.75*sampleTDS; 
1418:  MOVF   xF3,F
141A:  BNZ   146A
141C:  MOVF   xF2,W
141E:  SUBLW  B3
1420:  BNC   146A
1422:  MOVFF  2F3,301
1426:  MOVFF  2F2,300
142A:  MOVLB  0
142C:  CALL   08E4
1430:  MOVLB  3
1432:  CLRF   x01
1434:  CLRF   x00
1436:  MOVLW  30
1438:  MOVLB  2
143A:  MOVWF  xFF
143C:  MOVLW  80
143E:  MOVWF  xFE
1440:  MOVFF  03,305
1444:  MOVFF  02,304
1448:  MOVFF  01,303
144C:  MOVFF  00,302
1450:  MOVLB  0
1452:  CALL   0C0E
1456:  MOVFF  03,F4
145A:  MOVFF  02,F3
145E:  MOVFF  01,F2
1462:  MOVFF  00,F1
1466:  BRA    19E4
1468:  MOVLB  2
....................                  else if (sampleTDS<210) tdsValue=2.95*sampleTDS; 
146A:  MOVF   xF3,F
146C:  BNZ   14C0
146E:  MOVF   xF2,W
1470:  SUBLW  D1
1472:  BNC   14C0
1474:  MOVFF  2F3,301
1478:  MOVFF  2F2,300
147C:  MOVLB  0
147E:  CALL   08E4
1482:  MOVLW  CD
1484:  MOVLB  3
1486:  MOVWF  x01
1488:  MOVLW  CC
148A:  MOVWF  x00
148C:  MOVLW  3C
148E:  MOVLB  2
1490:  MOVWF  xFF
1492:  MOVLW  80
1494:  MOVWF  xFE
1496:  MOVFF  03,305
149A:  MOVFF  02,304
149E:  MOVFF  01,303
14A2:  MOVFF  00,302
14A6:  MOVLB  0
14A8:  CALL   0C0E
14AC:  MOVFF  03,F4
14B0:  MOVFF  02,F3
14B4:  MOVFF  01,F2
14B8:  MOVFF  00,F1
14BC:  BRA    19E4
14BE:  MOVLB  2
....................                     else if (sampleTDS<220) tdsValue=3.1*sampleTDS; 
14C0:  MOVF   xF3,F
14C2:  BNZ   1514
14C4:  MOVF   xF2,W
14C6:  SUBLW  DB
14C8:  BNC   1514
14CA:  MOVFF  2F3,301
14CE:  MOVFF  2F2,300
14D2:  MOVLB  0
14D4:  CALL   08E4
14D8:  MOVLW  66
14DA:  MOVLB  3
14DC:  MOVWF  x01
14DE:  MOVWF  x00
14E0:  MOVLW  46
14E2:  MOVLB  2
14E4:  MOVWF  xFF
14E6:  MOVLW  80
14E8:  MOVWF  xFE
14EA:  MOVFF  03,305
14EE:  MOVFF  02,304
14F2:  MOVFF  01,303
14F6:  MOVFF  00,302
14FA:  MOVLB  0
14FC:  CALL   0C0E
1500:  MOVFF  03,F4
1504:  MOVFF  02,F3
1508:  MOVFF  01,F2
150C:  MOVFF  00,F1
1510:  BRA    19E4
1512:  MOVLB  2
....................                          else if (sampleTDS<230) tdsValue=3.4*sampleTDS; 
1514:  MOVF   xF3,F
1516:  BNZ   156A
1518:  MOVF   xF2,W
151A:  SUBLW  E5
151C:  BNC   156A
151E:  MOVFF  2F3,301
1522:  MOVFF  2F2,300
1526:  MOVLB  0
1528:  CALL   08E4
152C:  MOVLW  9A
152E:  MOVLB  3
1530:  MOVWF  x01
1532:  MOVLW  99
1534:  MOVWF  x00
1536:  MOVLW  59
1538:  MOVLB  2
153A:  MOVWF  xFF
153C:  MOVLW  80
153E:  MOVWF  xFE
1540:  MOVFF  03,305
1544:  MOVFF  02,304
1548:  MOVFF  01,303
154C:  MOVFF  00,302
1550:  MOVLB  0
1552:  CALL   0C0E
1556:  MOVFF  03,F4
155A:  MOVFF  02,F3
155E:  MOVFF  01,F2
1562:  MOVFF  00,F1
1566:  BRA    19E4
1568:  MOVLB  2
....................                               else if (sampleTDS<240) tdsValue=3.67*sampleTDS; 
156A:  MOVF   xF3,F
156C:  BNZ   15C0
156E:  MOVF   xF2,W
1570:  SUBLW  EF
1572:  BNC   15C0
1574:  MOVFF  2F3,301
1578:  MOVFF  2F2,300
157C:  MOVLB  0
157E:  CALL   08E4
1582:  MOVLW  48
1584:  MOVLB  3
1586:  MOVWF  x01
1588:  MOVLW  E1
158A:  MOVWF  x00
158C:  MOVLW  6A
158E:  MOVLB  2
1590:  MOVWF  xFF
1592:  MOVLW  80
1594:  MOVWF  xFE
1596:  MOVFF  03,305
159A:  MOVFF  02,304
159E:  MOVFF  01,303
15A2:  MOVFF  00,302
15A6:  MOVLB  0
15A8:  CALL   0C0E
15AC:  MOVFF  03,F4
15B0:  MOVFF  02,F3
15B4:  MOVFF  01,F2
15B8:  MOVFF  00,F1
15BC:  BRA    19E4
15BE:  MOVLB  2
....................                                    else if (sampleTDS<250) tdsValue=3.95*sampleTDS; 
15C0:  MOVF   xF3,F
15C2:  BNZ   1616
15C4:  MOVF   xF2,W
15C6:  SUBLW  F9
15C8:  BNC   1616
15CA:  MOVFF  2F3,301
15CE:  MOVFF  2F2,300
15D2:  MOVLB  0
15D4:  CALL   08E4
15D8:  MOVLW  CD
15DA:  MOVLB  3
15DC:  MOVWF  x01
15DE:  MOVLW  CC
15E0:  MOVWF  x00
15E2:  MOVLW  7C
15E4:  MOVLB  2
15E6:  MOVWF  xFF
15E8:  MOVLW  80
15EA:  MOVWF  xFE
15EC:  MOVFF  03,305
15F0:  MOVFF  02,304
15F4:  MOVFF  01,303
15F8:  MOVFF  00,302
15FC:  MOVLB  0
15FE:  CALL   0C0E
1602:  MOVFF  03,F4
1606:  MOVFF  02,F3
160A:  MOVFF  01,F2
160E:  MOVFF  00,F1
1612:  BRA    19E4
1614:  MOVLB  2
....................                                         else if (sampleTDS<260) tdsValue=4.46*sampleTDS; 
1616:  MOVF   xF3,W
1618:  SUBLW  01
161A:  BNC   1670
161C:  BNZ   1624
161E:  MOVF   xF2,W
1620:  SUBLW  03
1622:  BNC   1670
1624:  MOVFF  2F3,301
1628:  MOVFF  2F2,300
162C:  MOVLB  0
162E:  CALL   08E4
1632:  MOVLW  52
1634:  MOVLB  3
1636:  MOVWF  x01
1638:  MOVLW  B8
163A:  MOVWF  x00
163C:  MOVLW  0E
163E:  MOVLB  2
1640:  MOVWF  xFF
1642:  MOVLW  81
1644:  MOVWF  xFE
1646:  MOVFF  03,305
164A:  MOVFF  02,304
164E:  MOVFF  01,303
1652:  MOVFF  00,302
1656:  MOVLB  0
1658:  CALL   0C0E
165C:  MOVFF  03,F4
1660:  MOVFF  02,F3
1664:  MOVFF  01,F2
1668:  MOVFF  00,F1
166C:  BRA    19E4
166E:  MOVLB  2
....................                                              else if (sampleTDS<265) tdsValue=4.85*sampleTDS; 
1670:  MOVF   xF3,W
1672:  SUBLW  01
1674:  BNC   16C8
1676:  BNZ   167E
1678:  MOVF   xF2,W
167A:  SUBLW  08
167C:  BNC   16C8
167E:  MOVFF  2F3,301
1682:  MOVFF  2F2,300
1686:  MOVLB  0
1688:  CALL   08E4
168C:  MOVLW  33
168E:  MOVLB  3
1690:  MOVWF  x01
1692:  MOVWF  x00
1694:  MOVLW  1B
1696:  MOVLB  2
1698:  MOVWF  xFF
169A:  MOVLW  81
169C:  MOVWF  xFE
169E:  MOVFF  03,305
16A2:  MOVFF  02,304
16A6:  MOVFF  01,303
16AA:  MOVFF  00,302
16AE:  MOVLB  0
16B0:  CALL   0C0E
16B4:  MOVFF  03,F4
16B8:  MOVFF  02,F3
16BC:  MOVFF  01,F2
16C0:  MOVFF  00,F1
16C4:  BRA    19E4
16C6:  MOVLB  2
....................                                                  else if (sampleTDS<270) tdsValue=5.06*sampleTDS;    
16C8:  MOVF   xF3,W
16CA:  SUBLW  01
16CC:  BNC   1722
16CE:  BNZ   16D6
16D0:  MOVF   xF2,W
16D2:  SUBLW  0D
16D4:  BNC   1722
16D6:  MOVFF  2F3,301
16DA:  MOVFF  2F2,300
16DE:  MOVLB  0
16E0:  CALL   08E4
16E4:  MOVLW  85
16E6:  MOVLB  3
16E8:  MOVWF  x01
16EA:  MOVLW  EB
16EC:  MOVWF  x00
16EE:  MOVLW  21
16F0:  MOVLB  2
16F2:  MOVWF  xFF
16F4:  MOVLW  81
16F6:  MOVWF  xFE
16F8:  MOVFF  03,305
16FC:  MOVFF  02,304
1700:  MOVFF  01,303
1704:  MOVFF  00,302
1708:  MOVLB  0
170A:  CALL   0C0E
170E:  MOVFF  03,F4
1712:  MOVFF  02,F3
1716:  MOVFF  01,F2
171A:  MOVFF  00,F1
171E:  BRA    19E4
1720:  MOVLB  2
....................                                                       else if (sampleTDS<275) tdsValue=5.26*sampleTDS; 
1722:  MOVF   xF3,W
1724:  SUBLW  01
1726:  BNC   177C
1728:  BNZ   1730
172A:  MOVF   xF2,W
172C:  SUBLW  12
172E:  BNC   177C
1730:  MOVFF  2F3,301
1734:  MOVFF  2F2,300
1738:  MOVLB  0
173A:  CALL   08E4
173E:  MOVLW  EC
1740:  MOVLB  3
1742:  MOVWF  x01
1744:  MOVLW  51
1746:  MOVWF  x00
1748:  MOVLW  28
174A:  MOVLB  2
174C:  MOVWF  xFF
174E:  MOVLW  81
1750:  MOVWF  xFE
1752:  MOVFF  03,305
1756:  MOVFF  02,304
175A:  MOVFF  01,303
175E:  MOVFF  00,302
1762:  MOVLB  0
1764:  CALL   0C0E
1768:  MOVFF  03,F4
176C:  MOVFF  02,F3
1770:  MOVFF  01,F2
1774:  MOVFF  00,F1
1778:  BRA    19E4
177A:  MOVLB  2
....................                                                            else if (sampleTDS<285) tdsValue=5.45*sampleTDS; 
177C:  MOVF   xF3,W
177E:  SUBLW  01
1780:  BNC   17D4
1782:  BNZ   178A
1784:  MOVF   xF2,W
1786:  SUBLW  1C
1788:  BNC   17D4
178A:  MOVFF  2F3,301
178E:  MOVFF  2F2,300
1792:  MOVLB  0
1794:  CALL   08E4
1798:  MOVLW  66
179A:  MOVLB  3
179C:  MOVWF  x01
179E:  MOVWF  x00
17A0:  MOVLW  2E
17A2:  MOVLB  2
17A4:  MOVWF  xFF
17A6:  MOVLW  81
17A8:  MOVWF  xFE
17AA:  MOVFF  03,305
17AE:  MOVFF  02,304
17B2:  MOVFF  01,303
17B6:  MOVFF  00,302
17BA:  MOVLB  0
17BC:  CALL   0C0E
17C0:  MOVFF  03,F4
17C4:  MOVFF  02,F3
17C8:  MOVFF  01,F2
17CC:  MOVFF  00,F1
17D0:  BRA    19E4
17D2:  MOVLB  2
....................                                                                 else if (sampleTDS<290) tdsValue=5.65*sampleTDS;  
17D4:  MOVF   xF3,W
17D6:  SUBLW  01
17D8:  BNC   182E
17DA:  BNZ   17E2
17DC:  MOVF   xF2,W
17DE:  SUBLW  21
17E0:  BNC   182E
17E2:  MOVFF  2F3,301
17E6:  MOVFF  2F2,300
17EA:  MOVLB  0
17EC:  CALL   08E4
17F0:  MOVLW  CD
17F2:  MOVLB  3
17F4:  MOVWF  x01
17F6:  MOVLW  CC
17F8:  MOVWF  x00
17FA:  MOVLW  34
17FC:  MOVLB  2
17FE:  MOVWF  xFF
1800:  MOVLW  81
1802:  MOVWF  xFE
1804:  MOVFF  03,305
1808:  MOVFF  02,304
180C:  MOVFF  01,303
1810:  MOVFF  00,302
1814:  MOVLB  0
1816:  CALL   0C0E
181A:  MOVFF  03,F4
181E:  MOVFF  02,F3
1822:  MOVFF  01,F2
1826:  MOVFF  00,F1
182A:  BRA    19E4
182C:  MOVLB  2
....................                                                                      else if (sampleTDS<295) tdsValue=5.95*sampleTDS;    
182E:  MOVF   xF3,W
1830:  SUBLW  01
1832:  BNC   1886
1834:  BNZ   183C
1836:  MOVF   xF2,W
1838:  SUBLW  26
183A:  BNC   1886
183C:  MOVFF  2F3,301
1840:  MOVFF  2F2,300
1844:  MOVLB  0
1846:  CALL   08E4
184A:  MOVLW  66
184C:  MOVLB  3
184E:  MOVWF  x01
1850:  MOVWF  x00
1852:  MOVLW  3E
1854:  MOVLB  2
1856:  MOVWF  xFF
1858:  MOVLW  81
185A:  MOVWF  xFE
185C:  MOVFF  03,305
1860:  MOVFF  02,304
1864:  MOVFF  01,303
1868:  MOVFF  00,302
186C:  MOVLB  0
186E:  CALL   0C0E
1872:  MOVFF  03,F4
1876:  MOVFF  02,F3
187A:  MOVFF  01,F2
187E:  MOVFF  00,F1
1882:  BRA    19E4
1884:  MOVLB  2
....................                                                                           else if (sampleTDS<300) tdsValue=6.35*sampleTDS; 
1886:  MOVF   xF3,W
1888:  SUBLW  01
188A:  BNC   18DE
188C:  BNZ   1894
188E:  MOVF   xF2,W
1890:  SUBLW  2B
1892:  BNC   18DE
1894:  MOVFF  2F3,301
1898:  MOVFF  2F2,300
189C:  MOVLB  0
189E:  CALL   08E4
18A2:  MOVLW  33
18A4:  MOVLB  3
18A6:  MOVWF  x01
18A8:  MOVWF  x00
18AA:  MOVLW  4B
18AC:  MOVLB  2
18AE:  MOVWF  xFF
18B0:  MOVLW  81
18B2:  MOVWF  xFE
18B4:  MOVFF  03,305
18B8:  MOVFF  02,304
18BC:  MOVFF  01,303
18C0:  MOVFF  00,302
18C4:  MOVLB  0
18C6:  CALL   0C0E
18CA:  MOVFF  03,F4
18CE:  MOVFF  02,F3
18D2:  MOVFF  01,F2
18D6:  MOVFF  00,F1
18DA:  BRA    19E4
18DC:  MOVLB  2
....................                                                                                else if (sampleTDS<305) tdsValue=6.55*sampleTDS; 
18DE:  MOVF   xF3,W
18E0:  SUBLW  01
18E2:  BNC   1938
18E4:  BNZ   18EC
18E6:  MOVF   xF2,W
18E8:  SUBLW  30
18EA:  BNC   1938
18EC:  MOVFF  2F3,301
18F0:  MOVFF  2F2,300
18F4:  MOVLB  0
18F6:  CALL   08E4
18FA:  MOVLW  9A
18FC:  MOVLB  3
18FE:  MOVWF  x01
1900:  MOVLW  99
1902:  MOVWF  x00
1904:  MOVLW  51
1906:  MOVLB  2
1908:  MOVWF  xFF
190A:  MOVLW  81
190C:  MOVWF  xFE
190E:  MOVFF  03,305
1912:  MOVFF  02,304
1916:  MOVFF  01,303
191A:  MOVFF  00,302
191E:  MOVLB  0
1920:  CALL   0C0E
1924:  MOVFF  03,F4
1928:  MOVFF  02,F3
192C:  MOVFF  01,F2
1930:  MOVFF  00,F1
1934:  BRA    19E4
1936:  MOVLB  2
....................                                                                                     else if (sampleTDS<310) tdsValue=6.65*sampleTDS;  
1938:  MOVF   xF3,W
193A:  SUBLW  01
193C:  BNC   1992
193E:  BNZ   1946
1940:  MOVF   xF2,W
1942:  SUBLW  35
1944:  BNC   1992
1946:  MOVFF  2F3,301
194A:  MOVFF  2F2,300
194E:  MOVLB  0
1950:  CALL   08E4
1954:  MOVLW  CD
1956:  MOVLB  3
1958:  MOVWF  x01
195A:  MOVLW  CC
195C:  MOVWF  x00
195E:  MOVLW  54
1960:  MOVLB  2
1962:  MOVWF  xFF
1964:  MOVLW  81
1966:  MOVWF  xFE
1968:  MOVFF  03,305
196C:  MOVFF  02,304
1970:  MOVFF  01,303
1974:  MOVFF  00,302
1978:  MOVLB  0
197A:  CALL   0C0E
197E:  MOVFF  03,F4
1982:  MOVFF  02,F3
1986:  MOVFF  01,F2
198A:  MOVFF  00,F1
198E:  BRA    19E4
1990:  MOVLB  2
....................                                                                                          else if (sampleTDS<315) tdsValue=6.75*sampleTDS; //3900ppm 
1992:  MOVF   xF3,W
1994:  SUBLW  01
1996:  BNC   19E6
1998:  BNZ   19A0
199A:  MOVF   xF2,W
199C:  SUBLW  3A
199E:  BNC   19E6
19A0:  MOVFF  2F3,301
19A4:  MOVFF  2F2,300
19A8:  MOVLB  0
19AA:  CALL   08E4
19AE:  MOVLB  3
19B0:  CLRF   x01
19B2:  CLRF   x00
19B4:  MOVLW  58
19B6:  MOVLB  2
19B8:  MOVWF  xFF
19BA:  MOVLW  81
19BC:  MOVWF  xFE
19BE:  MOVFF  03,305
19C2:  MOVFF  02,304
19C6:  MOVFF  01,303
19CA:  MOVFF  00,302
19CE:  MOVLB  0
19D0:  CALL   0C0E
19D4:  MOVFF  03,F4
19D8:  MOVFF  02,F3
19DC:  MOVFF  01,F2
19E0:  MOVFF  00,F1
19E4:  MOVLB  2
....................       }       
19E6:  BRA    1AA2
....................       else tdsValue=(6.75+(sampleTDS-310)/23.02)*sampleTDS; //hang so 23.02 tinh tu moc 3900ppm tai 310mv <=> kconst 6.75; 
19E8:  MOVLW  36
19EA:  SUBWF  xF2,W
19EC:  MOVWF  xF6
19EE:  MOVLW  01
19F0:  SUBWFB xF3,W
19F2:  MOVWF  xF7
19F4:  MOVFF  FE8,301
19F8:  MOVFF  2F6,300
19FC:  MOVLB  0
19FE:  CALL   08E4
1A02:  MOVFF  03,305
1A06:  MOVFF  02,304
1A0A:  MOVFF  01,303
1A0E:  MOVFF  00,302
1A12:  MOVLW  F6
1A14:  MOVLB  3
1A16:  MOVWF  x09
1A18:  MOVLW  28
1A1A:  MOVWF  x08
1A1C:  MOVLW  38
1A1E:  MOVWF  x07
1A20:  MOVLW  83
1A22:  MOVWF  x06
1A24:  MOVLB  0
1A26:  CALL   0688
1A2A:  BCF    FD8.1
1A2C:  MOVLB  3
1A2E:  CLRF   x05
1A30:  CLRF   x04
1A32:  MOVLW  58
1A34:  MOVWF  x03
1A36:  MOVLW  81
1A38:  MOVWF  x02
1A3A:  MOVFF  03,309
1A3E:  MOVFF  02,308
1A42:  MOVFF  01,307
1A46:  MOVFF  00,306
1A4A:  MOVLB  0
1A4C:  CALL   0996
1A50:  MOVFF  03,2F9
1A54:  MOVFF  02,2F8
1A58:  MOVFF  01,2F7
1A5C:  MOVFF  00,2F6
1A60:  MOVFF  2F3,301
1A64:  MOVFF  2F2,300
1A68:  CALL   08E4
1A6C:  MOVFF  2F9,301
1A70:  MOVFF  2F8,300
1A74:  MOVFF  2F7,2FF
1A78:  MOVFF  2F6,2FE
1A7C:  MOVFF  03,305
1A80:  MOVFF  02,304
1A84:  MOVFF  01,303
1A88:  MOVFF  00,302
1A8C:  CALL   0C0E
1A90:  MOVFF  03,F4
1A94:  MOVFF  02,F3
1A98:  MOVFF  01,F2
1A9C:  MOVFF  00,F1
1AA0:  MOVLB  2
....................       //moc tren 8700ppm tai 403mv <=> kconst=10.2; 
....................       tdsValue= tdsValue*2; 
1AA2:  MOVFF  F4,301
1AA6:  MOVFF  F3,300
1AAA:  MOVFF  F2,2FF
1AAE:  MOVFF  F1,2FE
1AB2:  MOVLB  3
1AB4:  CLRF   x05
1AB6:  CLRF   x04
1AB8:  CLRF   x03
1ABA:  MOVLW  80
1ABC:  MOVWF  x02
1ABE:  MOVLB  0
1AC0:  CALL   0C0E
1AC4:  MOVFF  03,F4
1AC8:  MOVFF  02,F3
1ACC:  MOVFF  01,F2
1AD0:  MOVFF  00,F1
1AD4:  GOTO   1B56 (RETURN)
.................... } 
.................... void erase_buffer_sim() 
.................... { 
....................    //xoa bo nho dem (dung de doc phan hoi sim trong ngat) 
....................    int i; 
....................    for(i=0;i<buffer_size;i++){ buffer[i]=0x00;} 
*
0404:  MOVLB  2
0406:  CLRF   xF1
0408:  MOVF   xF1,W
040A:  SUBLW  63
040C:  BNC   0422
040E:  CLRF   03
0410:  MOVF   xF1,W
0412:  ADDLW  FF
0414:  MOVWF  FE9
0416:  MOVLW  01
0418:  ADDWFC 03,W
041A:  MOVWF  FEA
041C:  CLRF   FEF
041E:  INCF   xF1,F
0420:  BRA    0408
....................    //buff_index=0x00; 
....................    return; 
0422:  MOVLB  0
0424:  RETURN 0
.................... } 
.................... /*int1 sendATcommand(char *command, char *expected_answer,unsigned int16 mstimeout) 
.................... { 
....................    //gui lenh cho sim co timeout 
....................    int1 answerAT=0; 
....................    buff_index=0; 
....................    erase_buffer_sim(); 
....................    //delay_ms(1000);//Delay to be sure no passed commands interfere 
....................    fprintf(UARTSIM,command); 
....................    fputc(13,UARTSIM); 
....................    fputc(10,UARTSIM); 
....................    delay_ms(500); //delay doi phan hoi  
....................    enSim=1; 
....................    do 
....................    { 
....................       if(strstr(buffer,expected_answer)!=NULL) 
....................       { 
....................          answerAT=1; 
....................       } 
....................       else answerAT=0; 
....................    } while((answerAT==0)&&(simCount<mstimeout)); 
....................    enSim=0; 
....................    simCount=0; 
....................    return answerAT; 
.................... }*/ 
....................  
.................... void batsim808() 
.................... { 
....................    //Khoi dong Sim 
....................    //Cho Module sim khoi dong,tam 15000ms 
....................    delay_ms(5000); 
0426:  MOVLW  14
0428:  MOVLB  2
042A:  MOVWF  xF1
042C:  MOVLW  FA
042E:  MOVWF  xFE
0430:  MOVLB  0
0432:  RCALL  0384
0434:  MOVLB  2
0436:  DECFSZ xF1,F
0438:  BRA    042C
....................    fprintf(UART1,"Bat MODULE SIM:\n");  
043A:  MOVLW  9E
043C:  MOVWF  FF6
043E:  MOVLW  01
0440:  MOVWF  FF7
0442:  MOVLB  0
0444:  RCALL  03AE
....................    fprintf(UART1,"Tat phan hoi sim: \n"); 
0446:  MOVLW  B0
0448:  MOVWF  FF6
044A:  MOVLW  01
044C:  MOVWF  FF7
044E:  RCALL  03AE
....................    fprintf(UARTSIM,"ATE0"); //ATE1: bat ATE0:tat phan hoi module sim 
0450:  MOVLW  C4
0452:  MOVWF  FF6
0454:  MOVLW  01
0456:  MOVWF  FF7
0458:  RCALL  03DA
....................    fputc(13,UARTSIM); 
045A:  MOVLW  0D
045C:  RCALL  03FC
....................    fputc(10,UARTSIM); 
045E:  MOVLW  0A
0460:  RCALL  03FC
....................    delay_ms(1000); 
0462:  MOVLW  04
0464:  MOVLB  2
0466:  MOVWF  xF1
0468:  MOVLW  FA
046A:  MOVWF  xFE
046C:  MOVLB  0
046E:  RCALL  0384
0470:  MOVLB  2
0472:  DECFSZ xF1,F
0474:  BRA    0468
....................    erase_buffer_sim(); 
0476:  MOVLB  0
0478:  RCALL  0404
....................    fprintf(UART1,"Kiem Tra Module Sim:\n");  
047A:  MOVLW  CA
047C:  MOVWF  FF6
047E:  MOVLW  01
0480:  MOVWF  FF7
0482:  RCALL  03AE
....................    fprintf(UARTSIM,"AT"); 
0484:  MOVLW  41
0486:  BTFSS  F9E.4
0488:  BRA    0486
048A:  MOVWF  FAD
048C:  MOVLW  54
048E:  BTFSS  F9E.4
0490:  BRA    048E
0492:  MOVWF  FAD
....................    fputc(13,UARTSIM); 
0494:  MOVLW  0D
0496:  RCALL  03FC
....................    fputc(10,UARTSIM); 
0498:  MOVLW  0A
049A:  RCALL  03FC
....................    delay_ms(1000); 
049C:  MOVLW  04
049E:  MOVLB  2
04A0:  MOVWF  xF1
04A2:  MOVLW  FA
04A4:  MOVWF  xFE
04A6:  MOVLB  0
04A8:  RCALL  0384
04AA:  MOVLB  2
04AC:  DECFSZ xF1,F
04AE:  BRA    04A2
....................    //time("OK",50); 
....................     
.................... //!   fprintf(UART1,"Set BAUD"); 
.................... //!   sendATcommand("AT+IPR=9600","OK",50); 
....................    //fprintf(UART1,"Cau hinh SMS:"); 
....................    //sendATcommand("AT+CMGF=1","OK",50); 
....................    erase_buffer_sim(); 
04B0:  MOVLB  0
04B2:  RCALL  0404
....................    fprintf(UART1,"Cau hinh SMS:"); 
04B4:  MOVLW  E0
04B6:  MOVWF  FF6
04B8:  MOVLW  01
04BA:  MOVWF  FF7
04BC:  RCALL  03AE
....................    fprintf(UARTSIM,"AT+CMGF=1"); 
04BE:  MOVLW  EE
04C0:  MOVWF  FF6
04C2:  MOVLW  01
04C4:  MOVWF  FF7
04C6:  RCALL  03DA
....................    fputc(13,UARTSIM); 
04C8:  MOVLW  0D
04CA:  RCALL  03FC
....................    fputc(10,UARTSIM); 
04CC:  MOVLW  0A
04CE:  RCALL  03FC
....................    delay_ms(2000); 
04D0:  MOVLW  08
04D2:  MOVLB  2
04D4:  MOVWF  xF1
04D6:  MOVLW  FA
04D8:  MOVWF  xFE
04DA:  MOVLB  0
04DC:  RCALL  0384
04DE:  MOVLB  2
04E0:  DECFSZ xF1,F
04E2:  BRA    04D6
....................     
....................    erase_buffer_sim(); 
04E4:  MOVLB  0
04E6:  RCALL  0404
....................    fprintf(UART1,"CAU HINH GPRS\n"); 
04E8:  MOVLW  F8
04EA:  MOVWF  FF6
04EC:  MOVLW  01
04EE:  MOVWF  FF7
04F0:  RCALL  03AE
....................    fprintf(UARTSIM,"AT+SAPBR=3,1,\"Contype\",\"GPRS\""); 
04F2:  MOVLW  08
04F4:  MOVWF  FF6
04F6:  MOVLW  02
04F8:  MOVWF  FF7
04FA:  RCALL  03DA
....................    fputc(13,UARTSIM); 
04FC:  MOVLW  0D
04FE:  RCALL  03FC
....................    fputc(10,UARTSIM); 
0500:  MOVLW  0A
0502:  RCALL  03FC
....................    delay_ms(2000); 
0504:  MOVLW  08
0506:  MOVLB  2
0508:  MOVWF  xF1
050A:  MOVLW  FA
050C:  MOVWF  xFE
050E:  MOVLB  0
0510:  RCALL  0384
0512:  MOVLB  2
0514:  DECFSZ xF1,F
0516:  BRA    050A
....................    //time("OK",100); 
....................    erase_buffer_sim(); 
0518:  MOVLB  0
051A:  RCALL  0404
....................    //cau hinh gprs 
....................    fprintf(UART1,"CAU HINH APN\n"); 
051C:  MOVLW  26
051E:  MOVWF  FF6
0520:  MOVLW  02
0522:  MOVWF  FF7
0524:  RCALL  03AE
....................    fprintf(UARTSIM,"AT+SAPBR=3,1,\"APN\",\"wap\""); 
0526:  MOVLW  34
0528:  MOVWF  FF6
052A:  MOVLW  02
052C:  MOVWF  FF7
052E:  RCALL  03DA
....................    fputc(13,UARTSIM); 
0530:  MOVLW  0D
0532:  RCALL  03FC
....................    fputc(10,UARTSIM); 
0534:  MOVLW  0A
0536:  RCALL  03FC
....................    delay_ms(2000); 
0538:  MOVLW  08
053A:  MOVLB  2
053C:  MOVWF  xF1
053E:  MOVLW  FA
0540:  MOVWF  xFE
0542:  MOVLB  0
0544:  RCALL  0384
0546:  MOVLB  2
0548:  DECFSZ xF1,F
054A:  BRA    053E
054C:  MOVLB  0
054E:  GOTO   24D2 (RETURN)
....................    //time("OK",100); 
....................    //fprintf("AT+SAPBR=3,1,\"APN\",\"wap\""); //cau hinh apn cho mang vietnammobile 
....................    //int answer=0; 
....................    //answer=sendATcommand("AT+HTTPINIT","OK",150); 
....................    //if(answer==1) 
....................    //{ 
....................      // fprintf(UART1,"HTTP PARA CID"); 
....................      // answer=sendATcommand("AT+HTTPPARA=\"CID\",1","OK",500); 
....................    //}    
.................... } 
.................... void sendData() //t tds ph do turb 
.................... { 
....................    erase_buffer_sim(); 
*
20AA:  CALL   0404
....................    fprintf(UART1,"\r\nSEND DATA\r\n"); 
20AE:  MOVLW  4E
20B0:  MOVWF  FF6
20B2:  MOVLW  02
20B4:  MOVWF  FF7
20B6:  CALL   03AE
....................    fprintf(UART1,"BAT GPRS\n"); 
20BA:  MOVLW  5C
20BC:  MOVWF  FF6
20BE:  MOVLW  02
20C0:  MOVWF  FF7
20C2:  CALL   03AE
....................    fprintf(UARTSIM,"AT+SAPBR=1,1"); 
20C6:  MOVLW  66
20C8:  MOVWF  FF6
20CA:  MOVLW  02
20CC:  MOVWF  FF7
20CE:  CALL   03DA
....................    fputc(13,UARTSIM); 
20D2:  MOVLW  0D
20D4:  CALL   03FC
....................    fputc(10,UARTSIM); 
20D8:  MOVLW  0A
20DA:  CALL   03FC
....................    delay_ms(2000); 
20DE:  MOVLW  08
20E0:  MOVLB  2
20E2:  MOVWF  xF1
20E4:  MOVLW  FA
20E6:  MOVWF  xFE
20E8:  MOVLB  0
20EA:  CALL   0384
20EE:  MOVLB  2
20F0:  DECFSZ xF1,F
20F2:  BRA    20E4
....................    //time("OK",350); 
....................    erase_buffer_sim(); 
20F4:  MOVLB  0
20F6:  CALL   0404
....................     
....................    fprintf(UART1,"KHOI TAO HTML\n"); 
20FA:  MOVLW  74
20FC:  MOVWF  FF6
20FE:  MOVLW  02
2100:  MOVWF  FF7
2102:  CALL   03AE
....................    fprintf(UARTSIM,"AT+HTTPINIT"); 
2106:  MOVLW  84
2108:  MOVWF  FF6
210A:  MOVLW  02
210C:  MOVWF  FF7
210E:  CALL   03DA
....................    fputc(13,UARTSIM); 
2112:  MOVLW  0D
2114:  CALL   03FC
....................    fputc(10,UARTSIM); 
2118:  MOVLW  0A
211A:  CALL   03FC
....................    delay_ms(2000); 
211E:  MOVLW  08
2120:  MOVLB  2
2122:  MOVWF  xF1
2124:  MOVLW  FA
2126:  MOVWF  xFE
2128:  MOVLB  0
212A:  CALL   0384
212E:  MOVLB  2
2130:  DECFSZ xF1,F
2132:  BRA    2124
....................    //time("OK",150); 
....................     
....................    erase_buffer_sim(); 
2134:  MOVLB  0
2136:  CALL   0404
....................     
....................    fprintf(UART1,"SEND URL: "); 
213A:  MOVLW  90
213C:  MOVWF  FF6
213E:  MOVLW  02
2140:  MOVWF  FF7
2142:  CALL   03AE
....................    sprintf(querystring,"AT+HTTPPARA=\"URL\",\"watervvv.000webhostapp.com/update_data.php?t=%2.1f&tds=%2.1f&do=%2.1f&ph=%2.1f&turb=%2.1f\"" 
....................    ,temperature,tdsValue,doValue,phValue,turb);  
2146:  MOVLB  2
2148:  CLRF   xF0
214A:  MOVLW  1D
214C:  MOVWF  xEF
214E:  MOVLW  9C
2150:  MOVWF  FF6
2152:  MOVLW  02
2154:  MOVWF  FF7
2156:  MOVLW  40
2158:  MOVWF  xF1
215A:  MOVLB  0
215C:  RCALL  1E7A
215E:  MOVLW  01
2160:  MOVWF  FE9
2162:  MOVFF  E8,2F4
2166:  MOVFF  E7,2F3
216A:  MOVFF  E6,2F2
216E:  MOVFF  E5,2F1
2172:  MOVLB  2
2174:  MOVWF  xF5
2176:  MOVLB  0
2178:  RCALL  1EA2
217A:  MOVLW  E1
217C:  MOVWF  FF6
217E:  MOVLW  02
2180:  MOVWF  FF7
2182:  MOVLW  05
2184:  MOVLB  2
2186:  MOVWF  xF1
2188:  MOVLB  0
218A:  RCALL  1E7A
218C:  MOVLW  01
218E:  MOVWF  FE9
2190:  MOVFF  F4,2F4
2194:  MOVFF  F3,2F3
2198:  MOVFF  F2,2F2
219C:  MOVFF  F1,2F1
21A0:  MOVLB  2
21A2:  MOVWF  xF5
21A4:  MOVLB  0
21A6:  RCALL  1EA2
21A8:  MOVLW  EB
21AA:  MOVWF  FF6
21AC:  MOVLW  02
21AE:  MOVWF  FF7
21B0:  MOVLW  04
21B2:  MOVLB  2
21B4:  MOVWF  xF1
21B6:  MOVLB  0
21B8:  RCALL  1E7A
21BA:  MOVLW  01
21BC:  MOVWF  FE9
21BE:  MOVFF  EC,2F4
21C2:  MOVFF  EB,2F3
21C6:  MOVFF  EA,2F2
21CA:  MOVFF  E9,2F1
21CE:  MOVLB  2
21D0:  MOVWF  xF5
21D2:  MOVLB  0
21D4:  RCALL  1EA2
21D6:  MOVLW  F4
21D8:  MOVWF  FF6
21DA:  MOVLW  02
21DC:  MOVWF  FF7
21DE:  MOVLW  04
21E0:  MOVLB  2
21E2:  MOVWF  xF1
21E4:  MOVLB  0
21E6:  RCALL  1E7A
21E8:  MOVLW  01
21EA:  MOVWF  FE9
21EC:  MOVFF  F0,2F4
21F0:  MOVFF  EF,2F3
21F4:  MOVFF  EE,2F2
21F8:  MOVFF  ED,2F1
21FC:  MOVLB  2
21FE:  MOVWF  xF5
2200:  MOVLB  0
2202:  RCALL  1EA2
2204:  MOVLW  FD
2206:  MOVWF  FF6
2208:  MOVLW  02
220A:  MOVWF  FF7
220C:  MOVLW  06
220E:  MOVLB  2
2210:  MOVWF  xF1
2212:  MOVLB  0
2214:  RCALL  1E7A
2216:  MOVLW  01
2218:  MOVWF  FE9
221A:  MOVFF  F8,2F4
221E:  MOVFF  F7,2F3
2222:  MOVFF  F6,2F2
2226:  MOVFF  F5,2F1
222A:  MOVLB  2
222C:  MOVWF  xF5
222E:  MOVLB  0
2230:  RCALL  1EA2
2232:  MOVLW  22
2234:  MOVLB  2
2236:  MOVWF  xFE
2238:  MOVLB  0
223A:  RCALL  1E5A
....................    fprintf(UART1,querystring); 
223C:  CLRF   FEA
223E:  MOVLW  1D
2240:  MOVWF  FE9
2242:  BRA    204E
....................    fprintf(UARTSIM,querystring); 
2244:  CLRF   FEA
2246:  MOVLW  1D
2248:  MOVWF  FE9
224A:  BRA    2082
....................    fputc(13,UARTSIM); 
224C:  MOVLW  0D
224E:  CALL   03FC
....................    fputc(10,UARTSIM); 
2252:  MOVLW  0A
2254:  CALL   03FC
....................    delay_ms(2000); 
2258:  MOVLW  08
225A:  MOVLB  2
225C:  MOVWF  xF1
225E:  MOVLW  FA
2260:  MOVWF  xFE
2262:  MOVLB  0
2264:  CALL   0384
2268:  MOVLB  2
226A:  DECFSZ xF1,F
226C:  BRA    225E
....................    //time("OK",250); 
....................     
....................     
....................    erase_buffer_sim(); 
226E:  MOVLB  0
2270:  CALL   0404
....................    //delay_ms(2000); 
....................    fprintf(UART1,"KHOI TAO CID \n"); 
2274:  MOVLW  0A
2276:  MOVWF  FF6
2278:  MOVLW  03
227A:  MOVWF  FF7
227C:  CALL   03AE
....................    fprintf(UARTSIM,"AT+HTTPPARA=\"CID\",1"); 
2280:  MOVLW  1A
2282:  MOVWF  FF6
2284:  MOVLW  03
2286:  MOVWF  FF7
2288:  CALL   03DA
....................    fputc(13,UARTSIM); 
228C:  MOVLW  0D
228E:  CALL   03FC
....................    fputc(10,UARTSIM); 
2292:  MOVLW  0A
2294:  CALL   03FC
....................    delay_ms(5000); 
2298:  MOVLW  14
229A:  MOVLB  2
229C:  MOVWF  xF1
229E:  MOVLW  FA
22A0:  MOVWF  xFE
22A2:  MOVLB  0
22A4:  CALL   0384
22A8:  MOVLB  2
22AA:  DECFSZ xF1,F
22AC:  BRA    229E
....................    //time("OK",500); 
....................     
....................     
....................    erase_buffer_sim(); 
22AE:  MOVLB  0
22B0:  CALL   0404
....................    //delay_ms(2000); 
....................    fprintf(UART1,"BAT DAU THUC HIEN HTHL \n"); 
22B4:  MOVLW  2E
22B6:  MOVWF  FF6
22B8:  MOVLW  03
22BA:  MOVWF  FF7
22BC:  CALL   03AE
....................    fprintf(UARTSIM,"AT+HTTPACTION=0"); 
22C0:  MOVLW  48
22C2:  MOVWF  FF6
22C4:  MOVLW  03
22C6:  MOVWF  FF7
22C8:  CALL   03DA
....................    fputc(13,UARTSIM); 
22CC:  MOVLW  0D
22CE:  CALL   03FC
....................    fputc(10,UARTSIM); 
22D2:  MOVLW  0A
22D4:  CALL   03FC
....................    delay_ms(5000); 
22D8:  MOVLW  14
22DA:  MOVLB  2
22DC:  MOVWF  xF1
22DE:  MOVLW  FA
22E0:  MOVWF  xFE
22E2:  MOVLB  0
22E4:  CALL   0384
22E8:  MOVLB  2
22EA:  DECFSZ xF1,F
22EC:  BRA    22DE
....................    //time("+HTTPACTION: 0,200",250); 
....................     
....................    
....................    erase_buffer_sim(); 
22EE:  MOVLB  0
22F0:  CALL   0404
....................    //delay_ms(2000); 
....................    fprintf(UART1,"TAT GPRS\n"); 
22F4:  MOVLW  58
22F6:  MOVWF  FF6
22F8:  MOVLW  03
22FA:  MOVWF  FF7
22FC:  CALL   03AE
....................    fprintf(UARTSIM,"AT+SAPBR=0,1"); 
2300:  MOVLW  62
2302:  MOVWF  FF6
2304:  MOVLW  03
2306:  MOVWF  FF7
2308:  CALL   03DA
....................    fputc(13,UARTSIM); 
230C:  MOVLW  0D
230E:  CALL   03FC
....................    fputc(10,UARTSIM); 
2312:  MOVLW  0A
2314:  CALL   03FC
....................    delay_ms(2000); 
2318:  MOVLW  08
231A:  MOVLB  2
231C:  MOVWF  xF1
231E:  MOVLW  FA
2320:  MOVWF  xFE
2322:  MOVLB  0
2324:  CALL   0384
2328:  MOVLB  2
232A:  DECFSZ xF1,F
232C:  BRA    231E
232E:  MOVLB  0
2330:  GOTO   26F8 (RETURN)
....................    //time("OK",350); 
....................     
....................    //erase_buffer_sim(); 
....................    //delay_ms(2000); 
....................   /* sendATcommand("AT+SAPBR=1,1","OK",350); // bat sim 
....................    delay_us(20); 
....................    sendATcommand("AT+HTTPINIT","OK",150);// khoi tao http 
....................     
....................    fprintf(UART1,"SEND URL: "); 
....................    sprintf(querystring,"AT+HTTPPARA=\"URL\",\"watervvv.000webhostapp.com/update_data.php?t=%2.1f&tds=%2.1f&do=%2.1f&ph=%2.1f&turb=%2.1f\"" 
....................    ,temperature,tdsValue,doValue,phValue,turb);    
....................    fprintf(UART1,querystring); 
....................    sendATcommand(querystring,"OK",250); 
....................    sendATcommand("AT+HTTPPARA=\"CID\",1","OK",500);//??? 
....................    fprintf(UART1,"HTTP ACTION"); 
....................    sendATcommand("AT+HTTPACTION=0","+HTTPACTION: 0,200",250);// start http 
....................     
....................    fprintf(UART1,"TAT GPRS"); 
....................    sendATcommand("AT+SAPBR=0,1","OK",250); // xong thi tat gprs*/ 
....................  
.................... } 
.................... void time(char *expected_answer,unsigned int16 time1) 
.................... { 
....................   erase_buffer_sim(); 
....................   int1 answerAT=0; 
....................   enSim=1; 
....................   do 
....................    { 
....................       if(strstr(buffer,expected_answer)!=NULL) 
....................       { 
....................          answerAT=1; 
....................       } 
....................       else answerAT=0; 
....................    } while((answerAT==0)&&(simCount<time1)); 
....................    enSim=0; 
....................    simCount=0; 
....................     
.................... } 
.................... void warning() 
.................... { 
.................... if ((temperature > 40) && (biendem==0)) 
.................... { 
....................    //i=1; 
....................    for(int j=0;j<10;j++) 
....................       { 
....................          readSensor(); 
....................          wartemp[j]=temperature; 
....................          delay_ms(1000); 
....................       } 
....................    int m=0; 
....................    while((wartemp[m]>=40)&&(m<10)) 
....................       { 
....................          m++; 
....................       } 
....................    //kiem tr neu 10 lan deu vuot nguong thi mowi canh bao sms 
....................    if (m==11) 
....................    { 
....................    sendSMS("Warning level 2"); 
....................    biendem=1; 
....................    } 
.................... } 
.................... if (temperature<=40) 
.................... biendem=0; 
.................... } 
.................... void sendSMS(char *s) 
.................... { 
.................... //!   disable_interrupts(GLOBAL); 
.................... //!   eeprom_read_string(0x00,phone,11);    
.................... //!   enable_interrupts(GLOBAL); 
.................... //!   if ((phone[10]<48)||(phone[10]>127))  
.................... //!   { 
.................... //!      phone[10]=0x22;   //"\"" 
.................... //!      phone[11]=0x00;   // nul 
.................... //!   } 
.................... //!   else phone[11]=0x22; //"\"" 
....................     
....................    char ch[25]=""; 
....................    phone = "0343366305\""; 
....................    //fprintf(UART1,"PHONE: %s\r\n",phone); 
....................    strcat(ch,"AT+CMGS=\""); 
....................    strcat(ch, phone); 
....................    fprintf(UART1,"chuoi gui tin: %s\r\n",ch); 
....................    fprintf(UARTSIM,ch); 
....................    fputc(13,UARTSIM); 
....................    fputc(10,UARTSIM); 
....................    delay_ms(4000); 
....................     
....................    fprintf(UARTSIM,"%s",s); 
....................    fputc(26,UARTSIM); 
....................    
.................... } 
....................  

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
